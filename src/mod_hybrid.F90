MODULE HYBRID

USE SET_KND
USE EOF_STR
USE GRD_STR
USE MYNETCDF
USE IOUNITS
USE ICE

IMPLICIT NONE

LOGICAL :: LL_HYBRID,LL_ALPHA_CTL,LSQUAREDEVA_H,&
& LL_BGFACT_H,LL_UNMASK_EOFS_H, LL_PRECON_ALPHA,LL_ALPHA_ONLINE
LOGICAL :: LL_DIAHYBRID, LL_DIAH = .FALSE.
REAL(R8), ALLOCATABLE :: PSV_DH(:,:,:)
INTEGER(I4) :: NN_ALPHA_CTL,NN_MLD_VLOC_H
REAL(R8)    :: ZALPHA, REDNMC_H, ZALPHA_VAR

TYPE(EOF_T) :: ROSH
INTEGER(I4), ALLOCATABLE :: REGHH(:,:),ILAT_ALP(:,:)
REAL(R8) :: ZHYB_A, ZHYB_B

REAL(R8), ALLOCATABLE :: &
& ALPHA(:), ALPHAB(:),ALPHA_AD(:),ALPHAV(:)

INTEGER(I4) :: NNA = 0
INTEGER(I4) :: CVH_S, CVH_E
INTEGER(I4) :: CVA_S, CVA_E
INTEGER(I4) :: NOTOT
REAL(R8), ALLOCATABLE, DIMENSION(:) :: BGERH,BGER,OERR,ORES
INTEGER(I4), ALLOCATABLE, DIMENSION(:) :: OPAR

LOGICAL :: LL_HYBRID_CR

CONTAINS 

SUBROUTINE SUEOFH

  IMPLICIT NONE

  INTEGER(I4)                 :: NRG, NEC, K, NSPL, I, J, KP, KP2, KP3
  INTEGER(I4)                 :: KSTP, NSLC,REGNUM, IERR
  INTEGER(I4) :: JPAR,JLEV,KK,KPARS,KRANK,KDIMS(3),KLEV

  REAL(R8) :: ZL(ROSH%NEOF,3)
  REAL(R8) :: ZC(ROSH%NEOF,ROSH%KMT,3)
  REAL(R8), ALLOCATABLE :: MLD(:,:), BGFAC2(:,:), BGFAC1(:)
  INTEGER(I4), ALLOCATABLE :: CNT(:)
  REAL(R8) :: ZMLD, ZL1, ZL2, ZDL, RPI
  LOGICAL  :: LL_MLD_VLOC_H

CALL MYFRTPROF_WALL('SUEOFH: SET-UP HYBRID EOF',0)

! ---
! EOFS

     WRITE(IOUNLOG,*)
     WRITE(IOUNLOG,*) '  /// EOFS SETUP FOR HYBRID SCHEME'

#ifdef opt_huge_memory
     CALL ABOR1('SUEOFH : opt_huge_memory NOT SUPPORTED FOR HYBRID')
#endif

     IF( LL_ALPHA_CTL ) THEN
         IF(NN_ALPHA_CTL .EQ. 1 ) NNA = 1
         IF(NN_ALPHA_CTL .EQ. 2 ) CALL ABOR1('NN_ALPHA_CTL 2 NOT YET SUPPORTED')
         ALLOCATE(ALPHA(NNA), ALPHA_AD(NNA), ALPHAB(NNA), &
         & ALPHAV(NNA) )
         ALPHAB = ZALPHA
         ALPHAV = ZALPHA_VAR
         WRITE(IOUNLOG,*) ' ALPHA CONTROL VECTOR '
         WRITE(IOUNLOG,*) ALPHAB, ALPHAV
         ALLOCATE(ILAT_ALP(GRD%IM,GRD%JM))
         IF(NN_ALPHA_CTL .EQ. 1 ) ILAT_ALP = 1
         IF(NN_ALPHA_CTL .EQ. 2 ) THEN
            WHERE(GRD%LAT.LE.-30._R8) ILAT_ALP = 1
            WHERE(GRD%LAT.GT.-30._R8.AND.GRD%LAT.LE.30._R8) ILAT_ALP = 2
            WHERE(GRD%LAT.GT. 30._R8) ILAT_ALP = 3
         ENDIF
     ENDIF
     
     IF(ROSH%EOGNX .LE. 0) ROSH%EOGNX=GRD%IM
     IF(ROSH%EOGNY .LE. 0) ROSH%EOGNY=GRD%JM
     IF(ROSH%EOGNZ .LE. 0) ROSH%EOGNZ=GRD%KM
     IF(ROSH%EOGNZ .NE. GRD%KM) THEN
          WRITE(IOUNERR,*) 'ROSH%EOGNZ != GRD%KM, ',ROSH%EOGNZ,GRD%KM
          WRITE(IOUNERR,*) '   THIS IS NOT SUPPORTED FOR THE TIME BEING'
          CALL ABOR1('SUEOFH: VERTICAL DIMENSION OF EOFS AND FIRST GUESS MISMATCH')
     ENDIF
     IF(ROSH%KMT .NE. GRD%KM*PSV3D + PSV2D) THEN
          CALL ABOR1('SUEOFH : KMT != STATE VECTOR')
     ENDIF

     IF(ROSH%NREG .EQ. 0 ) ROSH%NREG = GRD%IM*GRD%JM
     WRITE(IOUNLOG,*) ' EOF MODES    : ',ROSH%NEOF
     WRITE(IOUNLOG,*) ' EOF REGIONS  : ',ROSH%NREG
     WRITE(IOUNLOG,*) ' EOF LEVELS   : ',ROSH%KMT
     CALL FLUSH(IOUNLOG)

     ALLOCATE ( REGHH( GRD%IM, GRD%JM ))
     ALLOCATE ( GRD%ROH( GRD%IM, GRD%JM, ROSH%NEOF))
     ALLOCATE ( GRD%ROH_AD( GRD%IM, GRD%JM, ROSH%NEOF))
     ALLOCATE ( ROSH%EVC( ROSH%NREG, ROSH%KMT, ROSH%NEOF), ROSH%EVA( ROSH%NREG, ROSH%NEOF) )

     WRITE(IOUNLOG,*) ' EOF ALLOCATED, CALLING READ_NCEOF'
     CALL FLUSH(IOUNLOG)

     CALL READ_NCEOF(TRIM(ROSH%EOF_FILE),ROSH%NREG,GRD%IM,GRD%JM,&
     & ROSH%KMT,ROSH%NEOF,ROSH%EVA,ROSH%EVC,REGHH,LSQUAREDEVA_H)
   
     WRITE(IOUNLOG,*) ' READ_NCEOF CALLED'
     CALL FLUSH(IOUNLOG)

     IF( LL_ICEBGFILT ) CALL ICEBGFILT_H(ROSH,REGHH)

     IF(REDNMC_H.GT.0.1_R8 .AND. REDNMC.LT.10._R8) THEN
       WRITE(IOUNLOG,*)
       WRITE(IOUNLOG,*) ' *** USING REDNMC_H == ',REDNMC_H
       WRITE(IOUNLOG,*)
       ROSH%EVA=ROSH%EVA*REDNMC_H
     ENDIF

     IF(LL_BGFACT_H) THEN 
       ALLOCATE( BGFAC2(GRD%IM,GRD%JM) )
       ALLOCATE( BGFAC1(ROSH%NREG) )
       ALLOCATE( CNT  (ROSH%NREG) )
       CNT = 0
       BGFAC1 = 0._R8
       WRITE(IOUNLOG,*) ' READING GRID-DEPENDENT INFLATION OF B'
       CALL GETNCVAR('RATIO_BGERR_H.nc','ratio',GRD%IM,GRD%JM,BGFAC2)
       DO J=1,GRD%JM
         DO I=1,GRD%IM
           IF( GRD%MSK(I,J,1) .GT. 0.5_R8 ) THEN
             KK=REGHH(I,J)
             BGFAC1(KK) = BGFAC1(KK) + BGFAC2(I,J)
             CNT   (KK) = CNT   (KK) + 1
           ENDIF
         ENDDO
       ENDDO
       WRITE(IOUNLOG,*) ' MIN/MEAN/MAX VAL OF COUNTS :', &
       & MINVAL(CNT), SUM(CNT)/REAL(GRD%IM*GRD%JM), MAXVAL(CNT)
       WRITE(IOUNLOG,*) ' MIN/MEAN/MAX VAL OF COUNTS WITHOUT LAND :', &
       & MINVAL(CNT,MASK=(CNT>0)),&
       & SUM(CNT,MASK=(CNT>0))/REAL(SUM(GRD%MSK(:,:,1))),&
       & MAXVAL(CNT,MASK=(CNT>0))
       DEALLOCATE( BGFAC2 )
       WHERE( CNT .GT. 0 ) BGFAC1 = BGFAC1 / REAL(CNT,R8)
       WHERE( CNT .EQ. 0 ) BGFAC1 = 1._R8
       DO KK=1,ROSH%NEOF
           ROSH%EVA(:,KK)=ROSH%EVA(:,KK)*BGFAC1
       ENDDO
       DEALLOCATE( CNT, BGFAC1 )
     ENDIF

     DO KK=1,ROSH%NEOF
      DO J=1,GRD%JM
       DO I=1,GRD%IM
          ROSH%EVC(REGHH(I,J),1:GRD%KM,KK)=ROSH%EVC(REGHH(I,J),1:GRD%KM,KK)*GRD%MSK(I,J,:)
          ROSH%EVC(REGHH(I,J),(GRD%KM+1):(2*GRD%KM),KK)=ROSH%EVC(REGHH(I,J),(GRD%KM+1):(2*GRD%KM),KK)*GRD%MSK(I,J,:)
          IF( LL_TQ2 .AND. GRD%DISTC(I,J) .LT. 100000._R8) ROSH%EVC(REGHH(I,J),(2*GRD%KM+1):(2*GRD%KM+2),KK) = 0._R8
       ENDDO
      ENDDO
     ENDDO

     IF( IDOUBLEDOM .EQ. 2 ) THEN

        WRITE(IOUNLOG,*) ' *** INITIALIZING PHYSICAL SPACE CONTROL VECTOR'
        WRITE(IOUNLOG,*)
        WRITE(IOUNLOG,*) ' READING FROM CR ANINCR INCRO, DIMS ARE : ',&
        & GRD%IM,GRD%JM,ROSH%NEOF
        WRITE(IOUNLOG,*) ' SIZE OF GRD%RO IS', SIZE(GRD%ROH)
        CALL GETNCVAR('ANINCR_HR.NC','INCROH',GRD%IM,GRD%JM,ROSH%NEOF,GRD%ROH)

        WRITE(IOUNLOG,*) ' *** INITIALIZATION END'
        CALL FLUSH(IOUNLOG)
     ENDIF


     LL_MLD_VLOC_H = ( NN_MLD_VLOC_H .NE. 0 )
     ALLOCATE( GRD%MVLOC_H(GRD%IM,GRD%JM,ROSH%KMT) )
     GRD%MVLOC_H = 1._R8

     IF( LL_MLD_VLOC_H ) THEN
        ALLOCATE( MLD(GRD%IM,GRD%JM)  )
        CALL GETNCVAR('MLD.nc','somxl010',GRD%IM,GRD%JM,MLD )
        IF( NN_MLD_VLOC_H .EQ. 1 ) THEN
          DO J=1,GRD%JM 
            DO I=1,GRD%IM 
             IF( GRD%MSK(I,J,1) .GT. 0.5_R8 ) THEN
              DO K=1,GRD%KM
                IF( GRD%DEP(K) .LT. MLD(I,J) ) THEN
                    GRD%MVLOC_H(I,J,K) = 1._R8
                    KLEV=K
                ELSE
                    GRD%MVLOC_H(I,J,K) = 0._R8
                ENDIF
              ENDDO
             GRD%MVLOC_H(I,J,KLEV+1) = 0.5_R8
             ENDIF
            ENDDO
          ENDDO
        ELSE IF ( NN_MLD_VLOC_H .EQ. 2 ) THEN
         RPI = 2._R8*ASIN(1._R8)
         DO J=1,GRD%JM
          DO I=1,GRD%IM
           ZMLD = MLD(I,J)
           ZL1  = 10._R8
           IF ( ZMLD .LT. 15._R8 ) ZL1 = 5._R8
           ZL2  = ZMLD
           ZDL  = ZL2-ZL1
           DO K=1,GRD%KM
              IF( GRD%DEP(K) .LT. ZL1 ) THEN
                  GRD%MVLOC_H(I,J,K) = 1._R8
              ELSEIF ( GRD%DEP(K) .GT. ZL2 ) THEN
                  GRD%MVLOC_H(I,J,K) = 0._R8
              ELSE
                  GRD%MVLOC_H(I,J,K) = 0.5_R8*(1._R8-COS(RPI*(ZL2-GRD%DEP(K))/ZDL))
              ENDIF
           ENDDO
          ENDDO
         ENDDO
        ELSE
          WRITE(IOUNERR,*) ' NN_MLD_VLOC_H = ',NN_MLD_VLOC_H, ' NOT RECOGNIZED'
          CALL ABOR1('SUEOFSE : UNSUPPORTED NN_MLD_VLOC_H')
        ENDIF
        DEALLOCATE( MLD )
        DO K=2,PSV3D
            GRD%MVLOC_H(:,:,((K-1)*GRD%KM+1):(K*GRD%KM))=GRD%MVLOC_H(:,:,1:GRD%KM)
        ENDDO
     ENDIF

     IF (LL_UNMASK_EOFS_H) THEN
      DO K=2,GRD%KM
       KP=0
       KP2=0
       KP3=0
       DO J=1,GRD%JM 
        DO I=1,GRD%IM 
         KK=REGHH(I,J)
         IF( ALL(ROSH%EVC(KK,K,:).EQ.0._R8) .AND. GRD%MSK(I,J,K).GT.0.9_R8 ) THEN
           KP=KP+1
           IF( ALL(ROSH%EVC(KK,K-1,:).EQ.0._R8) ) THEN
              KP2=KP2+1
           ELSE
              KP3=KP3+1
              ROSH%EVC(KK,K,:) = ROSH%EVC(KK,K-1,:)
              ROSH%EVC(KK,K+GRD%KM,:) = ROSH%EVC(KK,K+GRD%KM-1,:)
           ENDIF
         ENDIF
        ENDDO
       ENDDO
       WRITE(IOUNLOG,*) ' LL_UNMASK_EOFS_H -- ', K, KP, KP2, KP3
      ENDDO
     ENDIF

     IF(LL_ALPHA_CTL) LL_ALPHA_ONLINE =.FALSE.

CALL MYFRTPROF_WALL('SUEOFH: SET-UP HYBRID EOF',1)
END SUBROUTINE SUEOFH

SUBROUTINE ALPHA_ONLINE

IMPLICIT NONE

INTEGER(I4), PARAMETER :: NNOI=100
REAL(R8)   , PARAMETER :: RNOI=1._R8/REAL(NNOI,R8)
INTEGER(I4), PARAMETER :: NNOI2=NNOI+1
REAL(R8) :: ZRES(NNOI2), ZA
INTEGER(I4) :: JJ,JP,JO

CALL BGSDEH_OBS

ZRES=0._R8
DO JJ=1,NNOI2
 ZA=(JJ-1)*RNOI 
 DO JO=1,NOTOT
  ZRES(JJ) = ZRES(JJ) + ABS( ORES(JO)**2 - (OERR(JO)**2 + ZA*BGER(JO)**2 +&
  & (1._R8-ZA)*BGERH(JO)**2 ) )
 ENDDO
ENDDO

WRITE(IOUNLOG,*) ZRES

JJ=MINLOC( ZRES, DIM=1 )
ZA=(JJ-1)*RNOI

WRITE(IOUNLOG,*) 'OPTIMAL ALPHA = ',JJ,ZA

DO JP=1,3

ZRES=0._R8
DO JJ=1,NNOI2
 ZA=(JJ-1)*RNOI
 DO JO=1,NOTOT
 IF( OPAR(JO) .EQ. JP .AND. ABS( BGERH(JO) ) .LT. 10._R8 ) &
 & ZRES(JJ) = ZRES(JJ) + ABS( ORES(JO)**2 - (OERR(JO)**2 + ZA*BGER(JO)**2 +&
 & (1._R8-ZA)*BGERH(JO)**2 ) )
 ENDDO
ENDDO

JJ=MINLOC( ZRES, DIM=1 )
ZA=(JJ-1)*RNOI

WRITE(IOUNLOG,*) 'OPTIMAL ALPHA = ',JP,JJ,ZA

ENDDO

DEALLOCATE( ORES, OERR, BGER, BGERH, OPAR )

END SUBROUTINE ALPHA_ONLINE

SUBROUTINE BGSDEH_OBS

  IMPLICIT NONE

  INTEGER (I4)               :: I, J, K, JOBS
  INTEGER (I4)               :: KI, JVL
  INTEGER (I4)               :: D, KP, I2, KBOT
  INTEGER (I4)               :: XIND1, JEOF,KKO
  REAL(R8)       :: BGTOT(GRD%IM,GRD%JM,GRD%KM,2)
  REAL(R8)       :: BGT(GRD%IM,GRD%JM,GRD%KM)
  REAL(R8)       :: BGS(GRD%IM,GRD%JM,GRD%KM)
  REAL(R8)       :: BGT2 (GRD%IM,GRD%JM)
  REAL(R8) ::  A2,A2_TL,B2,B2_TL,C2,ROOTS,RHOW_TL, T, S, ZRHO
  REAL(R8) ::  BGERR, RHTL, TB, SB
  REAL(R8), PARAMETER :: RHO0 = 1028._R8
  REAL(R8) ::  SLAEOF(ROSH%NREG,ROSH%NEOF)

  CALL MYFRTPROF_WALL('BGSDEH_OBS: FORM BG STDEV ERRORS FOR OBS',0)

  WRITE(IOUNLOG,*) 
  WRITE(IOUNLOG,*) ' FORMING BG ERRORS IN OBS SPACE'

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(K,J,I,KI)
!$OMP DO SCHEDULE(DYNAMIC,1)
#endif
    DO K=1,GRD%KM
     DO J=1,GRD%JM
      DO I=1,GRD%IM
        KI=REGHH(I,J)
        ! SALINITY
        BGTOT(I,J,K,1) = SQRT( SUM( ROSH%EVC(KI,K+GRD%KM,:) * &
        & ROSH%EVA(KI,:) * ROSH%EVA(KI,:) * ROSH%EVC(KI,K+GRD%KM,:) ) )
        ! TEMPERATURE
        BGTOT(I,J,K,2) = SQRT( SUM( ROSH%EVC(KI,K,:) * &
        & ROSH%EVA(KI,:) * ROSH%EVA(KI,:) * ROSH%EVC(KI,K,:) ) )
      ENDDO
     ENDDO
    ENDDO
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

    IF( SLA%NO .GT. 0 ) THEN

     ! READ CLIM
     CALL READ_CLIM(IANMM*100+IANDD,GRD%IM,GRD%JM,GRD%KM,BGT,BGS)

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(J,I,JEOF,KI,KBOT,RHTL,&
!$OMP & JVL,TB,SB,T,S,A2,A2_TL,B2,B2_TL,C2,ROOTS,RHOW_TL,ZRHO)
!$OMP DO SCHEDULE(DYNAMIC,1)
#endif
     DO J=1,GRD%JM
      DO I=1,GRD%IM
       DO JEOF=1,ROSH%NEOF
         KI=REGHH(I,J)
         KBOT=GRD%KM
         RHTL = 0._R8
         VLEV : DO JVL = KBOT,1,-1
           IF(GRD%MSK(I,J,JVL) .LT. 0.9_R8 ) CYCLE VLEV
           TB      = BGT(I,J,JVL)
           SB      = MAX(1.0_R8,BGS(I,J,JVL))
           T       = ROSH%EVC(KI,JVL,JEOF)
           S       = ROSH%EVC(KI,JVL+GRD%KM,JEOF)
#include "rho_unescotl_r8.h"
           RHTL = RHTL + ZRHO*GRD%DZ(JVL)
         ENDDO VLEV
         SLAEOF(KI,JEOF) = -1._R8*RHTL/RHO0
       ENDDO
       BGT2( I, J ) = SQRT( SUM( SLAEOF(KI,:) * &
       & ROSH%EVA(KI,:) * ROSH%EVA(KI,:) * SLAEOF(KI,:) ) )
     ENDDO
    ENDDO
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif
   ENDIF

NOTOT=INS%NO+SLA%NO+SST%NO+SSS%NO
ALLOCATE( BGERH(NOTOT) )
ALLOCATE( BGER (NOTOT) )
ALLOCATE( OERR (NOTOT) )
ALLOCATE( OPAR (NOTOT) )
ALLOCATE( ORES (NOTOT) )

KKO=0
IF( INS%NO .GT. 0 ) THEN
LOOPINS : DO JOBS=1,INS%NO

     IF(INS%FLC(JOBS) .NE. 1 ) CYCLE LOOPINS
     
     D=INS%KB(JOBS)
     KP=INS%PAR(JOBS)
     KKO=KKO+1

     BGERH(KKO) = &
     & OSUM( INS%PQ(JOBS,1:NPQ),BGTOT(INS%IB(JOBS,1:NPQ),INS%JB(JOBS,1:NPQ),D  ,KP) )+ &
     & OSUM( INS%PQ(JOBS,NPQ+1:2*NPQ),BGTOT(INS%IB(JOBS,1:NPQ),INS%JB(JOBS,1:NPQ),D+1,KP) )
     BGER(KKO) = INS%BGERR(JOBS)
     OERR(KKO) = INS%ERR(JOBS)
     ORES(KKO) = INS%RES(JOBS)
     OPAR(KKO) = INS%PAR(JOBS)

ENDDO LOOPINS
ENDIF

IF( SST%NO .GT. 0 ) THEN
LOOPSST : DO JOBS=1,SST%NO

     IF(SST%FLC(JOBS) .NE. 1 ) CYCLE LOOPSST

     D=1
     KP=2
     KKO=KKO+1
        
     BGERH(KKO) = &
     & OSUM( SST%PQ(JOBS,1:NPQ),BGTOT(SST%IB(JOBS,1:NPQ),SST%JB(JOBS,1:NPQ),D,KP) )
     BGER(KKO) = SST%BGERR(JOBS)
     OERR(KKO) = SST%ERR(JOBS)
     ORES(KKO) = SST%RES(JOBS)
     OPAR(KKO) = 4


ENDDO LOOPSST
ENDIF

IF( SSS%NO .GT. 0 ) THEN
LOOPSSS : DO JOBS=1,SSS%NO

     IF(SSS%FLC(JOBS) .NE. 1 ) CYCLE LOOPSSS

     D=1
     KP=1
     KKO=KKO+1

     BGERH(KKO) = &
     & OSUM( SSS%PQ(JOBS,1:NPQ),BGTOT(SSS%IB(JOBS,1:NPQ),SSS%JB(JOBS,1:NPQ),D,KP) )
     BGER(KKO) = SSS%BGERR(JOBS)
     OERR(KKO) = SSS%ERR(JOBS)
     ORES(KKO) = SSS%RES(JOBS)
     OPAR(KKO) = 5

ENDDO LOOPSSS
ENDIF


IF( SLA%NO .GT. 0 ) THEN
LOOPSLA : DO JOBS=1,SLA%NO

     IF(SLA%FLC(JOBS) .NE. 1 ) CYCLE LOOPSLA

     KKO=KKO+1
     BGERH(KKO) = &
     & OSUM( SLA%PQ(JOBS,1:NPQ),BGT2(SLA%IB(JOBS,1:NPQ),SLA%JB(JOBS,1:NPQ) ) )
     BGER(KKO) = SLA%BGERR(JOBS)
     OERR(KKO) = SLA%ERR(JOBS)
     ORES(KKO) = SLA%RES(JOBS)
     OPAR(KKO) = 3

ENDDO LOOPSLA
ENDIF

NOTOT=KKO

CALL MYFRTPROF_WALL('BGSDEH_OBS: FORM BG STDEV ERRORS FOR OBS',1)

END SUBROUTINE BGSDEH_OBS
END MODULE HYBRID
