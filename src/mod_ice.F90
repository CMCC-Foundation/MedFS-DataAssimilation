#undef SHARED_MEMORY
MODULE ICE

USE SET_KND
USE READFG
USE RUN
USE IOUNITS
USE GRD_STR
USE DRV_STR
USE OBSDEF
USE OBS_STR
USE EOF_STR
USE MYNETCDF
USE MYFRTPROF
USE MPIREL

IMPLICIT NONE

CHARACTER(LEN=60) :: CICEFILES(MAXFILES)
INTEGER(I4) :: NICEFILES
LOGICAL :: LLMPIA
LOGICAL :: LL_ICE_ONEFILE = .TRUE.
LOGICAL, PARAMETER :: LL_DEBICE = .FALSE.
REAL(R8), PARAMETER :: ZMINSIC = 0.01_R8
REAL   (R8), ALLOCATABLE, DIMENSION(:,:) :: SIMSK, SIDIST
INTEGER(I4) :: NN_ICEREC = 0

#include "grids.h"

CONTAINS

!============================================

SUBROUTINE ICE_INIT
IMPLICIT NONE
   ALLOCATE(GRD%ICE(GRD%IM,GRD%JM))
   IF( LL_ICE_ONEFILE ) THEN
     CALL GETNCVAR('icec.nc','soicecov',GRD%IM,GRD%JM,GRD%ICE)
   ELSE
     CALL READ_ICEFRAC(GRD%ICE)
   ENDIF
   GRD%ICE = GRD%ICE * GRD%MSK(:,:,1)
   LL_ICEINIT = .TRUE.
END SUBROUTINE ICE_INIT

!============================================

SUBROUTINE ICEREJECT

IMPLICIT NONE

INTEGER(I4) :: JOBS
INTEGER(I4) :: XIND1
INTEGER(I4) :: I1,I2,J1,J2
INTEGER(I4) :: JP_S, JP_N
REAL   (R8) :: ZICE

INTEGER(I4) :: NCOUNTS(NOFAMS)
INTEGER(I4) :: NCOUNTSD(NOFAMS)

#include "obs_events.h"

CALL MYFRTPROF_WALL('ICEREJECT: REJECT OBS UNDER SEA-ICE',0)

IF( .NOT. LL_ICEINIT ) CALL ICE_INIT

IF( LL_ICEREJ_DCOAST ) THEN
   JP_S = NN_END_SOUTHPOLE(NGRID_ID)
   JP_N = NN_BEG_NORTHPOLE(NGRID_ID)
   IF( JP_S .LT. 1 .OR. JP_N .LT. 1 ) THEN
       WRITE(IOUNOUT,*) 'GRID IS ',TRIM(DRV%CGRID(DRV%KTR))
       WRITE(IOUNOUT,*) '--> NOT YET SUPPORTED FOR SEA-ICE MASKERING'
       CALL ABOR1('GRID NOT SUPPORTED IN MOD_ICE')
   ENDIF
   ALLOCATE( SIMSK(GRD%IM,GRD%JM), SIDIST(GRD%IM,GRD%JM) )
   SIMSK = 0._R8
   WHERE( GRD%ICE .GT. ZMINSIC ) SIMSK = 1._R8
   CALL COFDIS_2D_ICE(GRD%IM,GRD%JM, JP_S, JP_N, &
   & GRD%LON, GRD%LAT, SIMSK, SIDIST )
   IF( LL_DEBICE ) CALL WRITE_VARNCDF('SIDIST.nc',GRD%IM,GRD%JM,&
   & SIDIST,'sidist','Km','Distance from sea-ice')
ENDIF

NCOUNTS = 0
NCOUNTSD = 0

IF(INS%NO .GT. 0) THEN
 CYO1 : DO JOBS=1,INS%NO
   IF( INS%FLC(JOBS) .NE. 1) CYCLE CYO1
   ZICE = GRD%ICE(INS%IB(JOBS,1),INS%JB(JOBS,1))
   IF( ZICE .GT. ZMINSIC ) THEN
        INS%FLC(JOBS) = 0
        INS%EVE(JOBS) = KEVE_ICER
        NCOUNTS(1) = NCOUNTS(1) + 1
   ENDIF
   IF( LL_ICEREJ_DCOAST .AND. INS%FLC(JOBS) .EQ. 1) THEN
     IF( SIDIST(INS%IB(JOBS,1),INS%JB(JOBS,1)) &
       & .LE. ZMIN_ICEDIST ) THEN
        INS%FLC(JOBS) = 0
        INS%EVE(JOBS) = KEVE_ICED
        NCOUNTSD(1) = NCOUNTSD(1) + 1
     ENDIF
   ENDIF
 ENDDO CYO1
ENDIF

IF(SLA%NO .GT. 0) THEN
 CYO2 : DO JOBS=1,SLA%NO
   IF( SLA%FLC(JOBS) .NE. 1) CYCLE CYO2
   ZICE = GRD%ICE(SLA%IB(JOBS,1),SLA%JB(JOBS,1))
   IF( ZICE .GT. ZMINSIC ) THEN
        SLA%FLC(JOBS) = 0
        SLA%EVE(JOBS) = KEVE_ICER
        NCOUNTS(2) = NCOUNTS(2) + 1
   ENDIF
   IF( LL_ICEREJ_DCOAST .AND. SLA%FLC(JOBS) .EQ. 1) THEN
     IF( SIDIST(SLA%IB(JOBS,1),SLA%JB(JOBS,1))  &
       & .LE. ZMIN_ICEDIST ) THEN
        SLA%FLC(JOBS) = 0
        SLA%EVE(JOBS) = KEVE_ICED
        NCOUNTSD(2) = NCOUNTSD(2) + 1
     ENDIF
   ENDIF
 ENDDO CYO2
ENDIF

IF(SST%NO .GT. 0) THEN
 CYO3 : DO JOBS=1,SST%NO
   IF( SST%FLC(JOBS) .NE. 1) CYCLE CYO3
   ZICE = GRD%ICE(SST%IB(JOBS,1),SST%JB(JOBS,1))
   IF( ZICE .GT. ZMINSIC ) THEN
        SST%FLC(JOBS) = 0
        SST%EVE(JOBS) = KEVE_ICER
        NCOUNTS(3) = NCOUNTS(3) + 1
   ENDIF
   IF( LL_ICEREJ_DCOAST .AND. SST%FLC(JOBS) .EQ. 1) THEN
     IF( SIDIST (SST%IB(JOBS,1),SST%JB(JOBS,1)) &
       & .LE. ZMIN_ICEDIST ) THEN
        SST%FLC(JOBS) = 0
        SST%EVE(JOBS) = KEVE_ICED
        NCOUNTSD(3) = NCOUNTSD(3) + 1
     ENDIF
   ENDIF
 ENDDO CYO3
ENDIF

IF(SSS%NO .GT. 0) THEN
 CYO4 : DO JOBS=1,SSS%NO
   IF( SSS%FLC(JOBS) .NE. 1) CYCLE CYO4
   ZICE = GRD%ICE(SSS%IB(JOBS,1),SSS%JB(JOBS,1))
   IF( ZICE .GT. ZMINSIC ) THEN
        SSS%FLC(JOBS) = 0
        SSS%EVE(JOBS) = KEVE_ICER
        NCOUNTS(4) = NCOUNTS(4) + 1
   ENDIF
   IF( LL_ICEREJ_DCOAST .AND. SSS%FLC(JOBS) .EQ. 1) THEN
     IF( SIDIST(SSS%IB(JOBS,1),SSS%JB(JOBS,1)) &
       & .LE. ZMIN_ICEDIST ) THEN
        SSS%FLC(JOBS) = 0
        SSS%EVE(JOBS) = KEVE_ICED
        NCOUNTSD(4) = NCOUNTSD(4) + 1
     ENDIF
   ENDIF
 ENDDO CYO4
ENDIF

WRITE(IOUNLOG,*)
WRITE(IOUNLOG,*) ' *** REJECTION OF OBS UNDER SEA-ICE'
WRITE(IOUNLOG,*) ' NO OF INSITU REJECTED :',NCOUNTS(1)
WRITE(IOUNLOG,*) ' NO OF SLA    REJECTED :',NCOUNTS(2)
WRITE(IOUNLOG,*) ' NO OF SST    REJECTED :',NCOUNTS(3)
WRITE(IOUNLOG,*) ' NO OF SSS    REJECTED :',NCOUNTS(4)
WRITE(IOUNLOG,*)

IF( LL_ICEREJ_DCOAST ) THEN
  WRITE(IOUNLOG,*)
  WRITE(IOUNLOG,*) ' *** REJECTION OF OBS TOO CLOSE TO SEA-ICE'
  WRITE(IOUNLOG,*) ' NO OF INSITU REJECTED :',NCOUNTSD(1)
  WRITE(IOUNLOG,*) ' NO OF SLA    REJECTED :',NCOUNTSD(2)
  WRITE(IOUNLOG,*) ' NO OF SST    REJECTED :',NCOUNTSD(3)
  WRITE(IOUNLOG,*) ' NO OF SSS    REJECTED :',NCOUNTSD(4)
ENDIF

IF( LL_ICEREJ_DCOAST .AND. .NOT. LL_ICEANFILT ) &
& DEALLOCATE( SIMSK, SIDIST )

CALL MYFRTPROF_WALL('ICEREJECT: REJECT OBS UNDER SEA-ICE',1)

END SUBROUTINE ICEREJECT

!============================================

SUBROUTINE ICERFMASK

USE RECFILTER, ONLY : LLMSR, LLMSR2

IMPLICIT NONE

INTEGER(I4) :: JX, JY

IF( .NOT. LL_ICEINIT ) CALL ICE_INIT

DO JY=1,GRD%JM
   DO JX=1,GRD%IM
     IF( GRD%ICE(JX,JY) .GT. ZMINSIC ) THEN
         LLMSR(JX,JY,:) = .FALSE.
         LLMSR2(JX,JY)  = .FALSE.
     ENDIF
   ENDDO
ENDDO

END SUBROUTINE ICERFMASK

!============================================

SUBROUTINE ICEBGFILT
IMPLICIT NONE

REAL(R8) :: ZICER(ROS%NREG), NCOUNT(ROS%NREG)
INTEGER(I4) :: JX, JY, IREG

CALL MYFRTPROF_WALL('ICEBGFILT: FILTER B UNDER SEA-ICE',0)

IF( .NOT. LL_ICEINIT ) CALL ICE_INIT

ZICER=0._R8
NCOUNT=0

DO JY=1,GRD%JM
  DO JX=1,GRD%IM
     IREG = GRD%REG(JX,JY)
     IF (IREG .GT. 0) THEN
        ZICER(IREG) = ZICER(IREG) + GRD%ICE(JX,JY)
        NCOUNT(IREG) = NCOUNT(IREG) + 1
     ENDIF
  ENDDO
ENDDO

WHERE( NCOUNT .GT. 0 ) ZICER = ZICER/REAL(NCOUNT,KIND=R8)

ZICER = 1._R8 - ZICER

DO JX=1,ROS%NREG
  ROS%EVA(JX,:) = ROS%EVA(JX,:) * ZICER(JX)
ENDDO

CALL MYFRTPROF_WALL('ICEBGFILT: FILTER B UNDER SEA-ICE',1)
END SUBROUTINE ICEBGFILT

!============================================

SUBROUTINE ICEANFILT
IMPLICIT NONE

INTEGER(I4) :: JX, JY, JP_S, JP_N
REAL(R8)    :: ZPI, ZDIST

CALL MYFRTPROF_WALL('ICEANFILT: FILTER ANALYSIS UNDER SEA-ICE',0)

IF( .NOT. LL_ICEINIT ) CALL ICE_INIT

IF( .NOT. ALLOCATED(SIDIST) ) THEN
   JP_S = NN_END_SOUTHPOLE(NGRID_ID)
   JP_N = NN_BEG_NORTHPOLE(NGRID_ID)
   IF( JP_S .LT. 1 .OR. JP_N .LT. 1 ) THEN
       WRITE(IOUNOUT,*) 'GRID IS ',TRIM(DRV%CGRID(DRV%KTR))
       WRITE(IOUNOUT,*) '--> NOT YET SUPPORTED FOR SEA-ICE MASKERING'
       CALL ABOR1('GRID NOT SUPPORTED IN MOD_ICE')
   ENDIF
   IF( .NOT. ALLOCATED ( SIMSK ) ) &
   ALLOCATE( SIMSK(GRD%IM,GRD%JM), SIDIST(GRD%IM,GRD%JM) )
   SIMSK = 1._R8
   WHERE( GRD%ICE .GT. ZMINSIC ) SIMSK = 0._R8
   CALL COFDIS_2D_ICE(GRD%IM,GRD%JM, JP_S, JP_N, &
   & GRD%LON, GRD%LAT, SIMSK, SIDIST )
   IF( LL_DEBICE ) THEN
    IF ( LMPION) THEN
     CALL WRITE_VARNCDF('SIDIST.nc'//'.'//TRIM(CMPIDOM),GRD%IM,GRD%JM,&
     & SIDIST,'sidist','Km','Distance from sea-ice')
    ELSE
     CALL WRITE_VARNCDF('SIDIST.nc',GRD%IM,GRD%JM,&
     & SIDIST,'sidist','Km','Distance from sea-ice')
    ENDIF
   ENDIF
   ZPI = ACOS(-1._R8)
ENDIF

DO JY=1,GRD%JM
  DO JX=1,GRD%IM
    IF( GRD%ICE(JX,JY) .GT. ZMINSIC ) THEN
        GRD%TEM(JX, JY, :) = 0._R8
        GRD%SAL(JX, JY, :) = 0._R8
    ELSE
        ZDIST = MIN( ZICEINFLDIST, SIDIST(JX, JY) )
        GRD%TEM(JX, JY, :) = GRD%TEM(JX, JY, :) * &
        & 0.5_R8 * (1._R8 - COS(ZPI*ZDIST/ZICEINFLDIST) )
        GRD%SAL(JX, JY, :) = GRD%SAL(JX, JY, :) * &
        & 0.5_R8 * (1._R8 - COS(ZPI*ZDIST/ZICEINFLDIST) )
    ENDIF
  ENDDO
ENDDO

DEALLOCATE(SIMSK, SIDIST)

CALL MYFRTPROF_WALL('ICEANFILT: FILTER ANALYSIS UNDER SEA-ICE',1)
END SUBROUTINE ICEANFILT

!============================================

SUBROUTINE SETICEFILES(NTF)

IMPLICIT NONE

INTEGER(I4), INTENT(IN) :: NTF
INTEGER(I4) :: JF

IF(NTF.GT.MAXFILES) THEN
   WRITE(IOUNERR,*) &
   & 'NUMBER OF ICE FILES EXCEEDS MAXIMUM ALLOWED'
   WRITE(IOUNERR,*) 'MAX ALLOWED =',MAXFILES,',  ACTUAL NO =',NTF
   CALL ABOR1('TOO MANY AN FILES')
ENDIF

WRITE(IOUNLOG,*)
WRITE(IOUNLOG,*) ' /// SETUP ICE FILENAMES'

IF(NTF.LE.0) THEN
   NICEFILES=1
   CICEFILES(1) = 'SIF.nc'
ELSE
   NICEFILES=NTF
   DO JF=1,NICEFILES
      WRITE(CICEFILES(JF),'(A,I4.4,A)') 'SIF_',JF+(NN_DOMSTART-1)-1,'.nc'
   ENDDO
ENDIF

LLMPIA = (NICEFILES.GT.1)

WRITE(IOUNLOG,*) ' NUMBER OF ICE FILES:',NICEFILES
WRITE(IOUNLOG,*) ' MULTI-PROC FILES  :',LLMPIA
WRITE(IOUNLOG,*)
WRITE(IOUNLOG,*) ' -------- NAMES OF ICE FILES --------'
DO JF=1,NICEFILES
   WRITE(IOUNLOG,*) JF,' '//TRIM(CICEFILES(JF))
ENDDO
WRITE(IOUNLOG,*)

CALL SETFGFLAYOUT

CALL FLUSH(IOUNLOG)
END SUBROUTINE SETICEFILES

!==============================================

SUBROUTINE READ_ICEFRAC(F3T)

USE GRD_STR
USE NETCDF

IMPLICIT NONE

CHARACTER(LEN=12) :: CVARNAME
INTEGER(I4)                    :: STAT,IDVAR,K,NCD
REAL(R8),INTENT(INOUT)  ::  F3T(GRD%IM,GRD%JM)

INTEGER(I4) :: X,Y,Z,MAXX,MAXY,MNZ,ISTARTX,ISTARTY,&
             & IENDX,IENDY,ILX,ILY,JF,KREC,NRECS

CALL MYFRTPROF_WALL('READ_ICEFRAC: READ ICE FRACTION FIELD',0)

WRITE(IOUNLOG,*) ' NUMBER OF SEA-ICE FILES :',NFGFILES
CALL FLUSH(IOUNLOG)

CALL SETICEFILES(NFGFILES)

MAXX=MAXVAL(KDSL(1:NFGFILES,1))
MAXY=MAXVAL(KDSL(1:NFGFILES,2))

CVARNAME = 'ileadfra'

F3T=0._R8

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED),PRIVATE(JF,ISTARTX,ISTARTY,IENDX,IENDY,ILX,ILY,&
!$OMP & STAT,IDVAR,NCD)
!$OMP DO SCHEDULE(STATIC,1)
#endif
DO JF=1,NICEFILES

   ISTARTX=KDPF(JF,1)
   ISTARTY=KDPF(JF,2)
   IENDX=KDPL(JF,1)
   IENDY=KDPL(JF,2)
   ILX=KDSL(JF,1)
   ILY=KDSL(JF,2)

#ifndef SHARED_MEMORY
   WRITE(IOUNLOG,*) 'FILE ',CICEFILES(JF), &
   & ISTARTX, ISTARTY, MAXX, MAXY, ISTARTX+MAXX-1, ISTARTY+MAXY-1,&
   & ILX, ILY
   CALL FLUSH(IOUNLOG)
#endif

   STAT = NF90_OPEN(CICEFILES(JF), NF90_NOWRITE, NCD)
   IF (STAT /= NF90_NOERR) CALL HANDLE_ERR(STAT)

   WRITE(IOUNLOG,*)
   WRITE(IOUNLOG,*) ' SEA-ICE FILE READING '

   IF( NN_ICEREC .EQ. 0 ) THEN
       CALL ABOR1('READ_ICEFRAC : REQUESTED RECORD HAS NOT BEEN SETUP')
   ELSEIF( NN_ICEREC .EQ. 1 ) THEN
       KREC = 1
       WRITE(IOUNLOG,*) ' NUMBER OF RECORD READ IN  : ', KREC
   ELSE
       STAT = NF90_INQ_DIMID (NCD, 'time_counter', IDVAR)
       IF (STAT /= NF90_NOERR) CALL HANDLE_ERR(STAT)
       STAT = NF90_INQUIRE_DIMENSION (NCD, IDVAR, LEN = NRECS)
       IF (STAT /= NF90_NOERR) CALL HANDLE_ERR(STAT)
       IF( NN_ICEREC .LT. 0 ) THEN
           KREC = NRECS
       ELSE
           KREC = NN_ICEREC
           IF( KREC .GT. NRECS ) THEN
               WRITE(IOUNLOG,*) ' NN_ICEREC IS GREATER THAN NUMBER OF RECORDS IN FILE'
               WRITE(IOUNLOG,*) ' NN_ICEREC = ', NN_ICEREC
               WRITE(IOUNLOG,*) ' NRECS     = ', NRECS
               CALL ABOR1('READ_ICEFRAC : REQUESTED RECORD IS GREATER THAN NO OF RECORDS')
           ENDIF
       ENDIF
       WRITE(IOUNLOG,*) ' NUMBER OF RECORDS IN FILE : ', NRECS
       WRITE(IOUNLOG,*) ' NUMBER OF RECORD READ IN  : ', KREC
   ENDIF

   STAT = NF90_INQ_VARID (NCD, CVARNAME, IDVAR)
   IF (STAT /= NF90_NOERR) CALL HANDLE_ERR(STAT)

   STAT = NF90_GET_VAR (NCD,IDVAR,F3T(ISTARTX:IENDX,ISTARTY:IENDY),&
   & START=(/1,1,KREC/),COUNT=(/ILX,ILY,1/))
   IF (STAT /= NF90_NOERR) CALL HANDLE_ERR(STAT)
  
   STAT = NF90_CLOSE(NCD)
   IF (STAT /= NF90_NOERR) CALL HANDLE_ERR(STAT)
ENDDO
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif
CALL MYFRTPROF_WALL('READ_ICEFRAC: READ ICE FRACTION FIELD',1)

END SUBROUTINE READ_ICEFRAC

SUBROUTINE COFDIS_2D_ICE(JPI, JPJ, JP_SOUTH, JP_NORTH, &
   & GLAMT, GPHIT, &
   & TMASK, PDCT )

   ! PROVIDES 2D DISTANCE IN KM
   ! 
   ! A.S. ADAPTED FROM NEMO 3.3
   ! SEMPLIFIED VERSION FOR NPERIO==3
   ! AND CONSIDERING ONLY T-POINTS
   ! FOR USE WITHIN SEA-ICE MASK

   IMPLICIT NONE

      INTEGER(I4) , INTENT( IN)  ::   JPI, JPJ, JP_SOUTH, JP_NORTH
      REAL(R8), DIMENSION(JPI,JPJ), INTENT( IN)  ::   GLAMT, GPHIT, &
      & TMASK
      REAL(R8), DIMENSION(JPI,JPJ), INTENT( OUT ) ::   PDCT
      !!
      INTEGER(I4) ::   JI, JJ, JL      ! DUMMY LOOP INDICES
      INTEGER(I4) ::   IJU, IJT            ! TEMPORARY INTEGERS
      INTEGER(I4) ::   ICOAST, ITIME
      INTEGER(I4) ::   ICOT, JPIM1, JPJM1
      LOGICAL, DIMENSION(JPI,JPJ) ::   LLCOTF   ! Coastal points
      REAL(R8) ::   ZDATE0
      REAL(R8), PARAMETER :: RA = 6371.229_R8
      REAL(R8), PARAMETER :: ZFILL = 100000._R8
      REAL(R8), PARAMETER :: RAD = 3.141592653589793_R8 / 180._R8
      INTEGER(I4) ::   JP_S, JP_N 

      ! CARTESIAN COORDINATES FOR T-POINTS
      REAL(R8), DIMENSION(JPI,JPJ)   ::   ZXT, ZYT, ZZT, ZMASK   

      ! TEMPORARY WORKSPACE
      REAL(R8), DIMENSION(3*JPI*JPJ) ::   ZXC, ZYC, ZZC, ZDIS    
      !!----------------------------------------------------------------------

      CALL MYFRTPROF_WALL('COFDIS_2D_ICE: SET DISTANCE TO SEA-ICE',0)

      PDCT(:,:) = ZFILL
      ZXT(:,:) = COS( RAD * GPHIT(:,:) ) * COS( RAD * GLAMT(:,:) )
      ZYT(:,:) = COS( RAD * GPHIT(:,:) ) * SIN( RAD * GLAMT(:,:) )
      ZZT(:,:) = SIN( RAD * GPHIT(:,:) )

      JPIM1 = JPI - 1
      JPJM1 = JPJ - 1

         ! DEFINE THE COASTLINE POINTS (U, V AND F)
         DO JJ = 2, JPJM1
            DO JI = 2, JPIM1
               ZMASK(JI,JJ) =  ( TMASK(JI,JJ+1) + TMASK(JI+1,JJ+1) &
                   &           + TMASK(JI,JJ  ) + TMASK(JI+1,JJ  ) )
               LLCOTF(JI,JJ) = ( ZMASK(JI,JJ)>0._R8 ).AND.(ZMASK(JI,JJ)<4._R8 )
            END DO
         END DO

         ! LATERAL BOUNDARIES CONDITIONS
         LLCOTF(:, 1 ) = TMASK(:,  2  ) == 1
         LLCOTF(:,JPJ) = TMASK(:,JPJM1) == 1

         LLCOTF( 1 ,:) = LLCOTF(JPIM1,:)
         LLCOTF(JPI,:) = LLCOTF(  2  ,:)

            DO JI = 1, JPIM1
               IJU = JPI - JI + 1
               LLCOTF(JI,JPJM1) = LLCOTF(IJU,JPJ-2)
               LLCOTF(JI,JPJ  ) = LLCOTF(IJU,JPJ-3)
            END DO

         ! COMPUTE CARTESIAN COORDINATES OF COASTLINE POINTS
         ! AND THE NUMBER OF COASTLINE POINTS
         ICOAST = 0
         DO JJ = 1, JPJ
            DO JI = 1, JPI
               IF( LLCOTF(JI,JJ) ) THEN
                  ICOAST = ICOAST + 1
                  ZXC(ICOAST) = COS( RAD*GPHIT(JI,JJ) ) * COS( RAD*GLAMT(JI,JJ) )
                  ZYC(ICOAST) = COS( RAD*GPHIT(JI,JJ) ) * SIN( RAD*GLAMT(JI,JJ) )
                  ZZC(ICOAST) = SIN( RAD*GPHIT(JI,JJ) )
               ENDIF
            END DO
         END DO

         ! DISTANCE FOR THE T-POINTS,
         ! ONLY WHERE WE SUSPECT ICE
         JP_S=0
         JP_N=JPJ+1
         IF ( JP_SOUTH>MP_YST(MYPROC) .AND. JP_SOUTH< MP_YEN(MYPROC) ) THEN
            JP_S=JP_SOUTH-MP_YST(MYPROC)+1
         ELSEIF ( JP_SOUTH> MP_YEN(MYPROC) ) THEN
            JP_S=JPJ
         ENDIF
         IF ( JP_NORTH>MP_YST(MYPROC) .AND. JP_NORTH< MP_YEN(MYPROC) ) THEN
            JP_N=JP_NORTH-MP_YST(MYPROC)+1
         ELSEIF ( JP_NORTH< MP_YST(MYPROC) ) THEN
            JP_N=1
         ENDIF

         DO JJ = 1, JP_S
            DO JI = 1, JPI
               IF( TMASK(JI,JJ) == 0._R8 ) THEN
                  PDCT(JI,JJ) = ZFILL
               ELSE
                  DO JL = 1, ICOAST
                     ZDIS(JL) = ( ZXT(JI,JJ) - ZXC(JL) )**2   &
                        &     + ( ZYT(JI,JJ) - ZYC(JL) )**2   &
                        &     + ( ZZT(JI,JJ) - ZZC(JL) )**2
                  END DO
                  PDCT(JI,JJ) = RA * SQRT( MINVAL( ZDIS(1:ICOAST) ) )
               ENDIF
            END DO
         END DO

         DO JJ = JP_N,JPJ
            DO JI = 1, JPI
               IF( TMASK(JI,JJ) == 0._R8 ) THEN
                  PDCT(JI,JJ) = ZFILL
               ELSE
                  DO JL = 1, ICOAST
                     ZDIS(JL) = ( ZXT(JI,JJ) - ZXC(JL) )**2   &
                        &     + ( ZYT(JI,JJ) - ZYC(JL) )**2   &
                        &     + ( ZZT(JI,JJ) - ZZC(JL) )**2
                  END DO
                  PDCT(JI,JJ) = RA * SQRT( MINVAL( ZDIS(1:ICOAST) ) )
               ENDIF
            END DO
         END DO


      CALL MYFRTPROF_WALL('COFDIS_2D_ICE: SET DISTANCE TO SEA-ICE',1)

   END SUBROUTINE COFDIS_2D_ICE

!============================================

SUBROUTINE ICEBGFILT_H(ROT,REG)
IMPLICIT NONE

INTEGER(I4),INTENT(IN) :: REG(GRD%IM,GRD%JM)
TYPE(EOF_T),INTENT(INOUT) :: ROT

REAL(R8) :: ZICER(ROT%NREG), NCOUNT(ROT%NREG)
INTEGER(I4) :: JX, JY, IREG

CALL MYFRTPROF_WALL('ICEBGFILT_H: FILTER B UNDER SEA-ICE',0)

IF( .NOT. LL_ICEINIT ) CALL ICE_INIT

ZICER=0._R8
NCOUNT=0

DO JY=1,GRD%JM
  DO JX=1,GRD%IM
     IREG = REG(JX,JY)
     ZICER(IREG) = ZICER(IREG) + GRD%ICE(JX,JY)
     NCOUNT(IREG) = NCOUNT(IREG) + 1
  ENDDO
ENDDO

WHERE( NCOUNT .GT. 0 ) ZICER = ZICER/REAL(NCOUNT,KIND=R8)

ZICER = 1._R8 - ZICER

DO JX=1,ROT%NREG
  ROT%EVA(JX,:) = ROT%EVA(JX,:) * ZICER(JX)
ENDDO

CALL MYFRTPROF_WALL('ICEBGFILT_H: FILTER B UNDER SEA-ICE',1)

END SUBROUTINE ICEBGFILT_H

!
END MODULE ICE
