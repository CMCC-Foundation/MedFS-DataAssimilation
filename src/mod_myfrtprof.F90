MODULE MYFRTPROF

!*** MYFRTPROF :::: MY FORTRAN PROFILER
!
!  MODULE MYFRTPROF -- AUTOMATIC TIME AND MEMORY PROFILING
!  -----------------------------------------------------------------
!
!  MODULE MYFRTPROF MAY BE USED TO TRACE AND PRINT
!  THE PARTIAL AND TOTAL TIME SPENT EACH TIME THAT
!  IT IS INVOKED FROM THE VERY FIRST CALL AS WELL
!  AS MEMORY, STACK AND PAGE CONSUMPTION.
!
!  USAGE:   CALL MYFRTPROF_WALL(CSTRING)
!           FOR COUNTING PARTIAL AND TOTAL TIME AFTER ACTION CSTRING
!
!           CALL MYFRTPROF_PRINT(UN1,OUT_UNIT)
!           FOR PRINTING TIME/MEMORY STATS (ON UNIT OUT_UNIT)
!
!  REMARKS FOR TIME PROFILING:
!           - IBM INTRINSEC IRTC() CAN BE CHOSEN AT COMPILATION
!             TIME (-D RS6K);
!           - FUJITSU INTRINSEC GETTOD() CAN BE CHOSEN AT COMPILATION
!             TIME (-D VPP);
!           - OTHERWISE, INTRINSEC SYSTEM_CLOCK IS USED.
!
!  REMARKS FOR MEMORY PROFILING:
!           - ORIGINAL FROM IFS/AUX LIBRARY;
!
!  RUNTIME OPTIONS:
!           - EXPORT MYFRTPROF=0 (SETENV MYFRTPROF 0 ) TO SWITCH IT OFF
!           - EXPORT MYFRTPROF_FILE='OUTPUT' (SETENV MYFRTPROF_FILE 'OUTPUT')
!             TO WRITE THE OUTPUT ON 'OUTPUT' (UNIT 699)
!
!  ANDREA STORTO - 04.11.2008 : ORIGINAL
!  ANDREA STORTO - 19.01.2009 : BETTER HANDLING OF OUTPUT UNIT
!

USE MPIREL , ONLY : LMPION, CMPIDOM

IMPLICIT NONE

INTEGER, PARAMETER :: JPRB = SELECTED_REAL_KIND(13,300)
INTEGER, PARAMETER :: JPIM = SELECTED_INT_KIND(9)
INTEGER, PARAMETER :: JPIB = SELECTED_INT_KIND(12)

LOGICAL, SAVE, PRIVATE :: LLCALLFIRST=.FALSE.
REAL(KIND=JPRB)   , SAVE, PRIVATE :: ZSTART
REAL(KIND=JPRB)   , SAVE, PRIVATE :: ZTIMELAST = 0._JPRB
INTEGER(KIND=JPIM), PRIVATE, PARAMETER :: NMAXT=999999
INTEGER(KIND=JPIM), PRIVATE, PARAMETER :: NCHS=50
CHARACTER(LEN=NCHS),SAVE,PRIVATE :: CTIMEACT(NMAXT)
CHARACTER(LEN=NCHS),SAVE,PRIVATE :: CTIMEACTCUM(NMAXT)
INTEGER(KIND=JPIM),SAVE,PRIVATE :: ILENC(NMAXT)
INTEGER(KIND=JPIM),SAVE,PRIVATE :: ITCOU (NMAXT)
REAL(KIND=JPRB)   ,SAVE,PRIVATE :: ZTCOU (NMAXT)
REAL(KIND=JPRB)   , SAVE, PRIVATE :: ZTIMES(2,NMAXT,0:2)
INTEGER(KIND=JPIM), SAVE ,PRIVATE :: ISTOPT = 0
INTEGER(KIND=JPIM), PRIVATE, PARAMETER :: NMEMKEYS=6
INTEGER(KIND=JPIB), SAVE, PRIVATE :: IMEM(NMEMKEYS,NMAXT)
LOGICAL,SAVE, PRIVATE :: LLSWITCH=.TRUE.
LOGICAL,SAVE, PRIVATE :: LLCHECKPOINT=.TRUE.

PRIVATE :: TIMEF
PRIVATE :: TIMECOUNT
PUBLIC  :: MYFRTPROF_WALL
PUBLIC  :: MYFRTPROF_PRINT

CONTAINS

SUBROUTINE GETMEMVALS(N, KEY, KVAL)

IMPLICIT NONE
INTEGER(KIND=JPIM), INTENT(IN) :: N, KEY(N)
INTEGER(KIND=JPIB), INTENT(OUT):: KVAL(N)

! 1 HIGH WATER MARK FOR HEAP-ALLOC
INTEGER(KIND=JPIB), EXTERNAL :: GETHWM
! 2 MAXIMUM RESIDENT MEMORY SO FAR
INTEGER(KIND=JPIB), EXTERNAL :: GETRSS
! 3 INSTANTANEOUS ALLOCATION FROM ALLOCATE/MALLOC
INTEGER(KIND=JPIB), EXTERNAL :: GETCURHEAP
! 4 INSTANTANEOUS STACK USAGE
INTEGER(KIND=JPIB), EXTERNAL :: GETSTK
! 5  MAXIMUM STACK USAGE SO FAR
INTEGER(KIND=JPIB), EXTERNAL :: GETMAXSTK
! 6  I/O CAUSED BY PAGING
INTEGER(KIND=JPIB), EXTERNAL :: GETPAG

INTEGER(KIND=JPIM) J

DO J=1,N
  IF (KEY(J) == 1) THEN
    KVAL(J) = GETHWM()
  ELSE IF (KEY(J) == 2) THEN
    KVAL(J) = GETRSS()
  ELSE IF (KEY(J) == 3) THEN
    KVAL(J) = GETCURHEAP()
  ELSE IF (KEY(J) == 4) THEN
    KVAL(J) = GETSTK()
  ELSE IF (KEY(J) == 5) THEN
    KVAL(J) = GETMAXSTK()
  ELSE IF (KEY(J) == 6) THEN
    KVAL(J) = GETPAG()
  ENDIF
ENDDO

END SUBROUTINE GETMEMVALS

!===================================================

FUNCTION TIMEF()
IMPLICIT NONE

#if defined VPP

REAL(KIND=JPRB) :: TIMEF
REAL(KIND=JPRB) :: ZTIMEF

!   FUJITSU SPECIAL

CALL GETTOD(ZTIMEF)
ZTIMEF=ZTIMEF/1000._JPRB

IF(.NOT.LLCALLFIRST) THEN
    LLCALLFIRST=.TRUE.
    ZSTART=ZTIMEF
    TIMEF=0._JPRB
ELSE
    TIMEF=(ZTIMEF-ZSTART)
ENDIF

#elif defined RS6K

REAL(KIND=JPRB) :: TIMEF
REAL(KIND=JPRB) :: ZTIMEF
INTEGER*8 :: IRTC
EXTERNAL :: IRTC

! IBM-XLF INTRINSEC

ZTIMEF=IRTC()/1000000._JPRB

IF(.NOT.LLCALLFIRST) THEN
     LLCALLFIRST=.TRUE.
     ZSTART=ZTIMEF
     TIMEF=0._JPRB
ELSE
     TIMEF=(ZTIMEF-ZSTART)
ENDIF

#else

REAL(KIND=JPRB) :: TIMEF
REAL(KIND=JPRB) :: ZTIMEF
INTEGER(KIND=JPIM) :: I_TIME1,I_RATE

! GENERIC INTRINSEC FORTRAN

CALL SYSTEM_CLOCK (COUNT=I_TIME1,COUNT_RATE=I_RATE)
ZTIMEF=REAL(I_TIME1,KIND=JPRB)/REAL(I_RATE,KIND=JPRB)

IF(.NOT.LLCALLFIRST) THEN
     LLCALLFIRST=.TRUE.
     ZSTART=ZTIMEF
     TIMEF=0._JPRB
ELSE
     TIMEF=1000._JPRB*(ZTIMEF-ZSTART)
ENDIF

#endif

RETURN
END FUNCTION TIMEF

!===================================================

SUBROUTINE TIMECOUNT(ZTIMETOT,ZTIMEPART)

IMPLICIT NONE

REAL(KIND=JPRB), INTENT(OUT) :: ZTIMETOT,ZTIMEPART
REAL(KIND=JPRB) :: ZTEMP

ZTEMP = TIMEF()

ZTIMETOT = ZTEMP
ZTIMEPART = ZTEMP - ZTIMELAST
ZTIMELAST = ZTIMETOT

RETURN
END SUBROUTINE TIMECOUNT

!===================================================

SUBROUTINE CHUMREAD(IKK,IST,CMEMSTR,IMM)

IMPLICIT NONE

INTEGER(KIND=JPIM),INTENT(IN) :: IKK,IST
INTEGER(KIND=JPIB),INTENT(IN) :: IMM(IKK,NMAXT)
CHARACTER(LEN=10),INTENT(OUT) :: CMEMSTR(IKK,NMAXT)
INTEGER(KIND=JPIM) :: JKK,JST
INTEGER(KIND=JPIB) :: ITMP1,ITMP2
CHARACTER(LEN=2) :: CMAGN,CLIST(0:8)
REAL(KIND=JPRB) :: ZFACT,ZTMP1

!... PRODUCE HUMAN-READABLE OUTPUT

CLIST(0)=' B'
CLIST(1)='KB'
CLIST(2)='MB'
CLIST(3)='GB'
CLIST(4)='TB'
CLIST(5)='PB'
CLIST(6)='EB'
CLIST(7)='ZB'
CLIST(8)='YB'

DO JKK=1,NMEMKEYS

    ZTMP1 = REAL(MAXVAL(IMM(JKK,1:IST)),KIND=JPRB)

    IF(ZTMP1.GT.0._JPRB) THEN
     ITMP2 = INT(LOG(ZTMP1)/LOG(1024._JPRB))
     IF(ITMP2.LT.0 .OR. ITMP2 .GT. 8) THEN
        ZFACT=1._JPRB
        CMAGN='  '
     ELSE
        CMAGN = CLIST(ITMP2)
        ZFACT = (1024._JPRB)**ITMP2
     ENDIF
    ELSE
     ZFACT=1._JPRB
     CMAGN='  '
    ENDIF

    DO JST=1,IST
         WRITE(CMEMSTR(JKK,JST),'(F7.2,X,A2)') &
         & REAL(IMM(JKK,JST),KIND=JPRB)/ZFACT,CMAGN(1:2)
    ENDDO

ENDDO

END SUBROUTINE CHUMREAD

!===================================================

SUBROUTINE MEMCOUNT(IKK,IMEMVALS)

IMPLICIT NONE

INTEGER(KIND=JPIM),INTENT(IN) :: IKK
INTEGER(KIND=JPIB),INTENT(OUT) :: IMEMVALS(IKK)
INTEGER(KIND=JPIM) :: IKEYS(IKK)

IKEYS(1:IKK) = (/1,2,3,4,5,6/)

CALL GETMEMVALS(IKK,IKEYS,IMEMVALS)
RETURN
END SUBROUTINE MEMCOUNT

!===================================================

SUBROUTINE MYFRTPROF_WALL(CSTRING,IPOINT)

IMPLICIT NONE

CHARACTER (LEN=*), INTENT(IN) :: CSTRING
CHARACTER (LEN=60)            :: CARG
INTEGER(KIND=JPIM) :: ILEN,IPOINT,JC,ITHIS

IF(.NOT.LLSWITCH) RETURN

IF(LLCHECKPOINT .AND. (IPOINT.NE.0 .AND. IPOINT.NE.1)) THEN
   WRITE(*,*) 'MYFRTPROF_WALL FOR '//TRIM(CSTRING)
   WRITE(*,*) 'CALLED WITH NOT VALID IPOINT (',IPOINT,')'
   CALL ABOR1('MYFRTPROF_WALL IRREGULARLY CALLED')
ENDIF

IF(.NOT.LLCALLFIRST) THEN
      CALL GETENV('MYFRTPROF',CARG)
      IF (LEN_TRIM(CARG) .GT. 0 ) THEN
          IF( CARG(1:1) .EQ. '0' ) THEN
             LLSWITCH=.FALSE.
             WRITE(*,*) ' MYFRTPROF IS SWITCHED OFF'
             WRITE(*,*)
          ELSE
             WRITE(*,*) ' MYFRTPROF IS SWITCHED ON'
             WRITE(*,*)
          ENDIF
      ELSE
          WRITE(*,*) ' MYFRTPROF IS SWITCHED ON'
          WRITE(*,*)
      ENDIF
      ZTIMES(1,:,1) = -1._JPRB
ENDIF

IF(IPOINT.EQ.0) THEN

  ISTOPT = ISTOPT + 1
  IF (ISTOPT .GT. NMAXT) CALL ABOR1 ('FUNCTION TIMESTOP: NMAXT TOO SMALL')
  ILEN=LEN(CSTRING)
  CTIMEACT(ISTOPT) = ' '

  IF (ILEN .LE. NCHS) THEN
    CTIMEACT(ISTOPT)(1:ILEN) = CSTRING(1:ILEN)
    ILENC(ISTOPT) = ILEN
  ELSE
    CTIMEACT(ISTOPT)(1:NCHS) = CSTRING(1:NCHS)
    ILENC(ISTOPT) = NCHS
  ENDIF

  ITHIS=ISTOPT

ELSE

  ITHIS=-1
  DO JC=1,ISTOPT
     IF( TRIM(CTIMEACT(JC)).EQ.TRIM(CSTRING) )ITHIS=JC
  ENDDO
  IF(ITHIS.EQ.-1 .AND. LLCHECKPOINT) THEN
     WRITE(*,*) 'MYFRTPROF: FAILED TO FIND INIT POINT FOR ',TRIM(CSTRING)
     CALL ABOR1('MYFRTPROF_WALL : NOT FOUND INITIAL POINT')
  ENDIF

ENDIF

CALL TIMECOUNT(ZTIMES(1,ITHIS ,IPOINT),ZTIMES(2,ITHIS ,IPOINT))

IF(IPOINT.EQ.1) &
& CALL MEMCOUNT(NMEMKEYS,IMEM(:,ISTOPT))

RETURN
END SUBROUTINE MYFRTPROF_WALL

!===================================================

SUBROUTINE MYFRTPROF_PRINT(IOUTIN,IOUT_TMP)
IMPLICIT NONE

INTEGER(KIND=JPIM),INTENT(IN) :: IOUTIN
INTEGER(KIND=JPIM),INTENT(IN),OPTIONAL :: IOUT_TMP
INTEGER(KIND=JPIM) :: JCOUNT,JKK,NOUT,IERR,IMYFILE,IOUT
INTEGER(KIND=JPIM) :: JCOUNT2,NDONE,IIT,IOUT2
CHARACTER(LEN=50)  :: CFRMT
CHARACTER(LEN=300)  :: CFILE
CHARACTER(LEN=10)  :: CMEMS(NMEMKEYS,NMAXT)
LOGICAL :: LDONE

IF(.NOT.LLSWITCH) RETURN

IOUT = IOUTIN

IMYFILE=699
NOUT=6
IF(IOUT.EQ.0 .OR. IOUT.EQ.6 .OR. IOUT.GT.12) THEN
        NOUT=IOUT
ELSEIF(IOUT.LT.0) THEN
        CALL GETENV('MYFRTPROF_FILE',CFILE)
        IF( LEN_TRIM(CFILE) .EQ. 0 ) THEN
          IF(LMPION) THEN
             CFILE='MYFRTPROF.OUT.'//TRIM(CMPIDOM)
          ELSE
             CFILE='MYFRTPROF.OUT'
          ENDIF
        ENDIF
        NOUT=IMYFILE
        OPEN(NOUT,FILE=CFILE,IOSTAT=IERR)
        IF(IERR.NE.0) THEN
            WRITE(0,*) &
          & 'MYFRTPROF: IMPOSSIBLE TO WRITE ON UNIT',&
          & IMYFILE,' FILE '//TRIM(CFILE)
            RETURN
        ENDIF
ELSE
        NOUT=6
ENDIF

IF(PRESENT(IOUT_TMP)) THEN
   IOUT2 = IOUT_TMP
ELSE
   IOUT2 = NOUT
ENDIF

WRITE(NOUT,'(A)')
WRITE(NOUT,'(A)') '///  MY_FORTRAN_PROFILER OUTPUTS'
WRITE(NOUT,'(A)') &
 & '-------------------------------------------------'//&
 & '------------------------------'

CALL CHUMREAD(NMEMKEYS,ISTOPT,CMEMS,IMEM)
WRITE(CFRMT,'(A,I1,A)') '(I4,X,F8.3,F8.3,',NMEMKEYS,'A10)'
DO JCOUNT=1,ISTOPT
   IF(ZTIMES(1,JCOUNT,1).LT.0._JPRB .AND. LLCHECKPOINT) THEN
      WRITE(*,*) 'MYFRTPROF: ',TRIM(CTIMEACT(JCOUNT)),&
      & ' CALLED BUT NO FINAL POINT'
   ENDIF
ENDDO
ZTIMES(1,1:ISTOPT,2) = ZTIMES(1,1:ISTOPT,1) - ZTIMES(1,1:ISTOPT,0)
WRITE(NOUT,'(A)') &
 & ' NO   TCPUTE  PCPUTE  HIGHWAME  MXRESMEM  INSALLOC'//&
 & '  INSTAUSA  MXSTAUSA  IOPAGING'
DO JCOUNT=1,ISTOPT
      WRITE(NOUT,CFRMT) JCOUNT, &
      & ZTIMES(1,JCOUNT,1)/1000._JPRB,ZTIMES(1,JCOUNT,2)/1000._JPRB,&
      & (CMEMS(JKK,JCOUNT),JKK=1,NMEMKEYS)
ENDDO
WRITE(NOUT,*)
WRITE(NOUT,'(A)') ' STEP   DESCRIPTION'
DO JCOUNT=1,ISTOPT
      WRITE(NOUT,'(2X,I4,2X,A)') JCOUNT,CTIMEACT(JCOUNT)(1:ILENC(JCOUNT))
ENDDO

WRITE(NOUT,*)
WRITE(NOUT,'(A)') '*** LEGEND'
WRITE(NOUT,'(A)') 'TCPUTE   : TOTAL CPU TIME ELAPSED'
WRITE(NOUT,'(A)') 'PCPUTE   : AVERAGED CPU TIME ELAPSED'
WRITE(NOUT,'(A)') 'HIGHWAME : HIGH WATER USED MEMORY'
WRITE(NOUT,'(A)') 'MXRESMEM : MAXIMUM RESIDENT MEMORY'
WRITE(NOUT,'(A)') 'INSALLOC : INSTANTANEOUS ALLOCATION OF MEMORY'
WRITE(NOUT,'(A)') 'INSTAUSA : INSTANTANEOUS STACK USAGE'
WRITE(NOUT,'(A)') 'MXSTAUSA : MAXIMUM STACK USAGE'
WRITE(NOUT,'(A)') 'IOPAGING : I/O CAUSE BY PAGING'
WRITE(NOUT,'(A)') &
 & '-------------------------------------------------'//&
 & '------------------------------'
WRITE(NOUT,*)

NDONE=1
CTIMEACTCUM(1) = CTIMEACT(1)
ITCOU=0
ZTCOU=0._JPRB
ITCOU(1) = 1
ZTCOU(1) = ZTIMES(1,1,2)/1000._JPRB
DO JCOUNT=2,ISTOPT
     LDONE=.FALSE.
     DO JCOUNT2=1,NDONE
        IF(CTIMEACTCUM(JCOUNT2) .EQ. CTIMEACT(JCOUNT)) THEN
           LDONE=.TRUE.
           ITCOU(JCOUNT2) = ITCOU(JCOUNT2) + 1
           ZTCOU(JCOUNT2) = ZTCOU(JCOUNT2) + ZTIMES(1,JCOUNT,2)/1000._JPRB
        ENDIF
     ENDDO
     IF(.NOT.LDONE) THEN
        NDONE= NDONE + 1
        ITCOU(NDONE) = 1
        ZTCOU(NDONE) = ZTIMES(1,JCOUNT,2)/1000._JPRB
        CTIMEACTCUM(NDONE) = CTIMEACT(JCOUNT)
     ENDIF
ENDDO

WHERE(ITCOU(1:NDONE).GT.0) ZTCOU(1:NDONE)=ZTCOU(1:NDONE)/ITCOU(1:NDONE)

WRITE(IOUT2,'(A)') &
 & '  N  CALL AVETIM  TOTTIM'

DO JCOUNT2=1,NDONE
      IIT=INDEX(CTIMEACTCUM(JCOUNT2),':')
      IF(IIT.EQ.0) IIT=31
      WRITE(IOUT2,'(I3,X,I5,X,F9.3,F10.3,X,A)') JCOUNT2, &
      & ITCOU(JCOUNT2),ZTCOU(JCOUNT2), ZTCOU(JCOUNT2)*ITCOU(JCOUNT2),&
      & CTIMEACTCUM(JCOUNT2)(1:IIT-1)
ENDDO

WRITE(IOUT2,*)
WRITE(IOUT2,'(A)') 'STEP  DESCRIPTION'
DO JCOUNT2=1,NDONE
      WRITE(IOUT2,'(2X,I3,2X,A)') JCOUNT2,CTIMEACTCUM(JCOUNT2)
ENDDO

IF(NOUT.EQ.IMYFILE) CLOSE(NOUT)

END SUBROUTINE MYFRTPROF_PRINT

!===================================================

END MODULE MYFRTPROF
