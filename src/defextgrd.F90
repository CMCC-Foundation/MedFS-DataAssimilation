SUBROUTINE DEFEXTGRD
USE RECFILTER

!-- DEFINE EXTENDED GRID

USE GRD_STR

IMPLICIT  NONE

INTEGER(KIND=I4) :: NX,NY,NZ,IERR
INTEGER(KIND=I4) :: I,J,K,KK,K2,JLEV

WRITE(IOUNLOG,*)
WRITE(IOUNLOG,*) ' /// DEFINE EXTENDED GRID'
WRITE(IOUNLOG,*)

#ifndef USE_POINTERS
IF( .NOT.ALLOCATED(GRD%DX).OR..NOT.ALLOCATED(GRD%DY).OR.&
  & .NOT.ALLOCATED(GRD%MSR)) THEN
   WRITE(IOUNERR,*) 'DEFEXTGRD CALLED BEFORE GRID INITIALIZATION'
   CALL ABOR1('ERROR IN DEFEXTGRD, CANNOT PROCEED')
ENDIF
#endif

IF(.NOT.LLRFINIT) &
& CALL ABOR1('DEFEXTGRD CALLED BEFORE RF INITIALIZATION')

NX=GRD%IM
NY=GRD%JM
NZ=GRD%KM

WRITE(IOUNLOG,*) 'NUMBER OF SEA POINTS (%):',&
& REAL(COUNT(LLMSR(:,:,1)),KIND=R8)*100._R8/(NX*NY)
WRITE(IOUNLOG,*) 'NUMBER OF SEA POINTS, 3-D (%):',&
& REAL(COUNT(LLMSR(:,:,:)),KIND=R8)*100._R8/(NX*NY*NZ)

ALLOCATE(ISTPNS(NX,NY,NTOTV),JSTPNS(NX,NY,NTOTV),STAT=IERR)
IF(IERR.NE.0) THEN
   WRITE(IOUNERR,*) 'CANNOT ALLOCATE ISTPNS,JSTPNS'
   CALL ABOR1('DEFEXTGRD: ALLOCATION PROBLEMS')
ENDIF
ALLOCATE(IMX(NTOTV),JMX(NTOTV),STAT=IERR)
IF(IERR.NE.0) THEN
   WRITE(IOUNERR,*) 'CANNOT ALLOCATE IMX,JMX'
   CALL ABOR1('DEFEXTGRD: ALLOCATION PROBLEMS')
ENDIF
ALLOCATE(INX(NX,NY,NTOTV),JNX(NX,NY,NTOTV),STAT=IERR)
IF(IERR.NE.0) THEN
   WRITE(IOUNERR,*) 'CANNOT ALLOCATE INX,JNX'
   CALL ABOR1('DEFEXTGRD: ALLOCATION PROBLEMS')
ENDIF

WRITE(IOUNLOG,*) 'VECTORS HAVE BEEN ALLOCATED' ; CALL FLUSH(IOUNLOG)

!... MOVED TO RDGRDS

DO JLEV=1,NTOTV

   ISTPNS(:,:,JLEV) = INT(ZGA_CRAD(JLEV)*RF_EFC / GRD%DX(:,:) )+1
   JSTPNS(:,:,JLEV) = INT(ZGA_CRAD(JLEV)*RF_EFC / GRD%DY(:,:) )+1

   IF (LL_PRINT_RECFILT) THEN
      WRITE(IOUNLOG,*) 'INITIAL ISTPNS: ',JLEV,ZGA_CRAD(JLEV),RF_EFC,MINVAL(GRD%DX(:,:)),&
      & MAXVAL(GRD%DX(:,:)),SUM(GRD%DX(:,:))/(NX*NY),MINVAL(ISTPNS(:,:,JLEV)),&
      & MAXVAL(ISTPNS(:,:,JLEV)),SUM(ISTPNS(:,:,JLEV))/(NX*NY)
      WRITE(IOUNLOG,*) 'INITIAL JSTPNS: ',JLEV,ZGA_CRAD(JLEV),RF_EFC,MINVAL(GRD%DY(:,:)),&
      & MAXVAL(GRD%DY(:,:)),SUM(GRD%DY(:,:))/(NX*NY),MINVAL(JSTPNS(:,:,JLEV)),&
      & MAXVAL(JSTPNS(:,:,JLEV)),SUM(JSTPNS(:,:,JLEV))/(NX*NY)
   ENDIF
ENDDO

IMAX   = 0
JMAX   = 0

DO K=1,NTOTV
   K2=K
   IF(K2.GT.NZ) K2=K2-NZ
   IMX(K) = 0
   DO J=1,NY
      KK=ISTPNS(1,J,K)
      IF( LLMSR(1,J,K2) ) KK=KK+1
      INX(1,J,K) = KK
      DO I=2,NX
         IF(.NOT.LLMSR(I,J,K2).AND.LLMSR(I-1,J,K2)) THEN
            KK=KK+ISTPNS(I,J,K)
         ELSEIF(LLMSR(I,J,K2).AND..NOT.LLMSR(I-1,J,K2))THEN
            KK=KK+ISTPNS(I,J,K)+1
         ELSEIF(LLMSR(I,J,K2)) THEN
            KK=KK+1
         ENDIF
         INX(I,J,K) = KK
      ENDDO
      IMX(K) = MAX( IMX(K), KK+ISTPNS(NX,J,K))
   ENDDO
   IMAX   = MAX(IMAX,IMX(K))
   IF (LL_PRINT_RECFILT) THEN
      WRITE(IOUNLOG,*) 'IMX(',K,') = ',IMX(K)
   ENDIF

   JMX(K) = 0
   DO I=1,NX
      KK=JSTPNS(I,1,K)
      IF( LLMSR(I,1,K2) ) KK=KK+1
      JNX(I,1,K) = KK
      DO J=2,NY
         IF(.NOT.LLMSR(I,J,K2).AND.LLMSR(I,J-1,K2)) THEN
            KK=KK+JSTPNS(I,J,K)
         ELSEIF(LLMSR(I,J,K2).AND..NOT.LLMSR(I,J-1,K2))THEN
            KK=KK+JSTPNS(I,J,K)+1
         ELSEIF(LLMSR(I,J,K2)) THEN
            KK=KK+1
         ENDIF
         JNX(I,J,K) = KK
      ENDDO
      JMX(K) = MAX( JMX(K), KK+JSTPNS(I,NY,K))
   ENDDO
   JMAX   = MAX(JMAX,JMX(K))

ENDDO

WRITE(IOUNLOG,*) 'IMAX,JMAX = ',IMAX,JMAX

WRITE(IOUNLOG,*) 'END' ; CALL FLUSH(IOUNLOG)
RETURN
END SUBROUTINE DEFEXTGRD
