SUBROUTINE BGQCHECKP

!.. PERFORM BACKGROUND QUALITY CHECK
!.. AND REJECT OBSERVATIONS ACCORDINGLY
!.. USES SPATIALLY-VARYING BACKGROUND-ERROR
!..
!.. IT WORKS AS FOLLOWS:
!..
!.. EVALUATE [Y-H(XB)]**2 > ALFA * ( SIGMAB**2 + SIGMAO**2)
!.. WHERE SIGMAB AND SIGMAO ARE BACKGROUND AND OBSERVATIONAL
!.. ERRORS, RESPECTIVELY, AND ALFA IS A USER-DEFINED FACTOR.
!.. WHEN THE RELATION IS SATISFIED, THE OBS IS REJECTED.
!..
!.. ANDREA STORTO *INGV* 2009-03-30

USE SET_KND
USE OBSDEF
USE OBS_STR
USE GRD_STR
USE IOUNITS, ONLY : IOUNLOG
USE MYNETCDF
USE OBSHANDLING , ONLY : LLBGQC_SLA, LLBGQC_INS, LLBGQC_SST, RALFA_SLA, &
                       & RALFA_INS, RBGERR_SSH, RBGERR_SAL, &
                       & RBGERR_TEM ,RALFA_SST,&
                       & RBGERR_SST,&
                       & LLBGQC_SSS, RALFA_SSS, RBGERR_SSS
USE MYFRTPROF, ONLY : MYFRTPROF_WALL
USE MPIREL

IMPLICIT NONE

REAL(R8) :: ZBGETAERR,ZBGSSTERR,ZBGSSSERR,BGERR
REAL(R8) :: ZTOTVAR
REAL(R8) :: ZOMGP2
REAL(R8) :: ZRATIO
REAL(R8) :: ZALFA_SLA,ZALFA_INS,ZALFA_SST,ZALFA_SSS
INTEGER (I4) :: JOBS,KREJ(4),KNUM(4),I,J,D,I2,KP
INTEGER (I4) :: XIND1, KX1, KX2
REAL(R8) :: RALF_INS(NOINSITU,NOPARAMS)
LOGICAL :: LL_ALPHA_FF

#include "obs_events.h"

CALL MYFRTPROF_WALL('BGQCHECKP: BACKGROUND QUALITY CHECK',0)

KREJ=0
KNUM=0

!... SLA PART

IF(LLBGQC_SLA .AND. SLA%NO .GT. 0) THEN

ZALFA_SLA = RALFA_SLA   ! FIXED ALFA FOR SLA

!#ifdef SHARED_MEMORY
!!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(JOBS,ZOMGP2,ZTOTVAR,ZRATIO,I,J,I2,BGERR)
!!$OMP DO SCHEDULE(STATIC,1)
!#endif
LOOPSLA : DO JOBS=1,SLA%NO

     IF(SLA%FLC(JOBS) .EQ. 0 ) CYCLE LOOPSLA

     ZOMGP2 = SLA%RES(JOBS)*SLA%RES(JOBS)

     ZTOTVAR = SLA%BGERR(JOBS)*SLA%BGERR(JOBS) + SLA%ERR(JOBS)*SLA%ERR(JOBS)

     ZRATIO = ZOMGP2 / ZTOTVAR

     IF(ZRATIO .GT. ZALFA_SLA ) THEN
        SLA%FLC(JOBS) = 0
        SLA%EVE(JOBS) = KEVE_BGQC
     ENDIF

ENDDO LOOPSLA
!#ifdef SHARED_MEMORY
!!$OMP END DO
!!$OMP END PARALLEL
!#endif

KREJ(1) = COUNT( SLA%EVE(1:SLA%NO) .EQ. KEVE_BGQC )
KNUM(1) = SUM(SLA%FLC(1:SLA%NO))

ENDIF

!... INS PART

IF(LLBGQC_INS  .AND. INS%NO .GT. 0) THEN

ZALFA_INS = RALFA_INS
LL_ALPHA_FF = .FALSE.
IF( ZALFA_INS .LE. 0._R8 ) LL_ALPHA_FF = .TRUE.

IF( LL_ALPHA_FF ) THEN
 CALL GETNCVAR('alpha_limits.nc','alpha_ins',NOINSITU,NOPARAMS,RALF_INS)
 WRITE(IOUNLOG,*) ' /// BGQC : INSITU LIMITS READ IN FROM FILE'
   DO KX2=1,NOPARAMS
     DO KX1=1,NOINSITU
        WRITE(IOUNLOG,'(A,I3,A,I3,A,F8.3)') ' ::: ALPHA LIMITS, PAR ',KX2,' TYPE ',KX1, &
        & ' = ',RALF_INS(KX1,KX2)
     ENDDO
   ENDDO

ENDIF

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(JOBS,ZOMGP2,ZTOTVAR,ZRATIO,I,J,D,I2,KP,BGERR)
!$OMP DO SCHEDULE(STATIC,1)
#endif
LOOPINS : DO JOBS=1,INS%NO

     IF(INS%FLC(JOBS) .EQ. 0 ) CYCLE LOOPINS

     ZOMGP2 = INS%RES(JOBS)*INS%RES(JOBS)

     ZTOTVAR = INS%BGERR(JOBS)*INS%BGERR(JOBS) + INS%ERR(JOBS)*INS%ERR(JOBS)

     ZRATIO = ZOMGP2 / ZTOTVAR

     IF( LL_ALPHA_FF ) ZALFA_INS = RALF_INS(INS%KTY(JOBS),INS%PAR(JOBS))

     IF(ZRATIO .GT. ZALFA_INS ) THEN
        INS%FLC(JOBS) = 0
        INS%EVE(JOBS) = KEVE_BGQC
     ENDIF

ENDDO LOOPINS
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

KREJ(2) = COUNT( INS%EVE(1:INS%NO) .EQ. KEVE_BGQC )
KNUM(2) = SUM(INS%FLC(1:INS%NO))

ENDIF

!... SST PART

IF(LLBGQC_SST .AND. SST%NO .GT. 0) THEN

ZBGSSTERR    = RBGERR_SST
ZALFA_SST = RALFA_SST

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(JOBS,ZOMGP2,ZTOTVAR,ZRATIO,I,J,I2,BGERR)
!$OMP DO SCHEDULE(STATIC,1)
#endif
LOOPSST : DO JOBS=1,SST%NO

     IF(SST%FLC(JOBS) .EQ. 0 ) CYCLE LOOPSST

     ZOMGP2 = SST%RES(JOBS)*SST%RES(JOBS)

     ZTOTVAR = SST%BGERR(JOBS)*SST%BGERR(JOBS) + SST%ERR(JOBS)*SST%ERR(JOBS)

     ZRATIO = ZOMGP2 / ZTOTVAR

     IF(ZRATIO .GT. ZALFA_SST ) THEN
        SST%FLC(JOBS) = 0
        SST%EVE(JOBS) = KEVE_BGQC
     ENDIF

ENDDO LOOPSST
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

KREJ(3) = COUNT( SST%EVE(1:SST%NO) .EQ. KEVE_BGQC )
KNUM(3) = SUM(SST%FLC(1:SST%NO))

ENDIF

IF(LLBGQC_SSS .AND. SSS%NO .GT. 0) THEN

ZBGSSSERR    = RBGERR_SSS
ZALFA_SSS = RALFA_SSS

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(JOBS,ZOMGP2,ZTOTVAR,ZRATIO,I,J,I2,BGERR)
!$OMP DO SCHEDULE(STATIC,1)
#endif
LOOPSSS : DO JOBS=1,SSS%NO

     IF(SSS%FLC(JOBS) .EQ. 0 ) CYCLE LOOPSSS

     ZOMGP2 = SSS%RES(JOBS)*SSS%RES(JOBS)

     ZTOTVAR = SSS%BGERR(JOBS)*SSS%BGERR(JOBS) + SSS%ERR(JOBS)*SSS%ERR(JOBS)

     ZRATIO = ZOMGP2 / ZTOTVAR

     IF(ZRATIO .GT. ZALFA_SSS ) THEN
        SSS%FLC(JOBS) = 0
        SSS%EVE(JOBS) = KEVE_BGQC
     ENDIF

ENDDO LOOPSSS
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

KREJ(4) = COUNT( SSS%EVE(1:SSS%NO) .EQ. KEVE_BGQC )
KNUM(4) = SUM(SSS%FLC(1:SSS%NO))

ENDIF

WRITE(IOUNLOG,*)
WRITE(IOUNLOG,*) ' *** BACKGROUND QUALITY CHECK'
WRITE(IOUNLOG,*) ' SLA REJ/RET/TOT:',KREJ(1),KNUM(1),SLA%NO
WRITE(IOUNLOG,*) ' INS REJ/RET/TOT:',KREJ(2),KNUM(2),INS%NO
WRITE(IOUNLOG,*) ' SST REJ/RET/TOT:',KREJ(3),KNUM(3),SST%NO
WRITE(IOUNLOG,*) ' SSS REJ/RET/TOT:',KREJ(4),KNUM(4),SSS%NO
WRITE(IOUNLOG,*)

CALL MYFRTPROF_WALL('BGQCHECKP: BACKGROUND QUALITY CHECK',1)
END SUBROUTINE BGQCHECKP
