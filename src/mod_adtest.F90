MODULE ADTEST

USE SET_KND
USE GRD_STR
USE RANDOM_NUMBERS
USE TLAD_VARS

IMPLICIT NONE

INTERFACE RANDOM_FLD
         MODULE PROCEDURE RANDOM_FLD_3D, RANDOM_FLD_2D, RANDOM_FLD_1D, &
RANDOM_FLD_4D, RANDOM_FLD_3DB
END INTERFACE
INTERFACE MDOT_PRODUCT
         MODULE PROCEDURE MDOT_PRODUCT_3D, MDOT_PRODUCT_2D, MDOT_PRODUCT_4D,&
MDOT_PRODUCT_4, MDOT_PRODUCT_3DB
END INTERFACE

TYPE(RANDOMNUMBERSTREAM), PRIVATE :: GOLUM
LOGICAL :: LLINIT_RND = .FALSE.
LOGICAL, PARAMETER :: LL_WEIMULT = .FALSE.

CONTAINS

REAL(R8) FUNCTION MDOT_PRODUCT_4D(ZV1,ZV2,NI,NJ,NK,NT)
IMPLICIT NONE
INTEGER(I4), INTENT(IN) :: NI,NJ,NK,NT
REAL(R8), INTENT(IN) :: ZV1(NI,NJ,NK,NT)
REAL(R8), INTENT(IN) :: ZV2(NI,NJ,NK,NT)
REAL(R8) :: ZV1V(NI*NJ*NK*NT)
REAL(R8) :: ZV2V(NI*NJ*NK*NT)
INTEGER(I4) :: KK,JI,JJ,JK,JT
KK=0
DO JT=1,NT
DO JK=1,NK
 DO JJ=1,NJ
  DO JI=1,NI
   KK=KK+1
   ZV1V(KK) = ZV1(JI,JJ,JK,JT)
   ZV2V(KK) = ZV2(JI,JJ,JK,JT)
  ENDDO
 ENDDO
ENDDO
ENDDO
MDOT_PRODUCT_4D = DOT_PRODUCT(ZV1V,ZV2V)

END FUNCTION MDOT_PRODUCT_4D

REAL(R8) FUNCTION MDOT_PRODUCT_3DB(ZV1,ZV2,NI,NJ,NK)
IMPLICIT NONE
INTEGER(I4), INTENT(IN) :: NI,NJ,NK
REAL(R8), INTENT(IN) :: ZV1(NI,NJ,NK)
REAL(R8), INTENT(IN) :: ZV2(NI,NJ,NK)
REAL(R8) :: ZV1V(NI*NJ*NK)
REAL(R8) :: ZV2V(NI*NJ*NK)
INTEGER(I4) :: KK,JI,JJ,JK
KK=0
DO JK=1,NK
 DO JJ=1,NJ
  DO JI=1,NI
   KK=KK+1
   ZV1V(KK) = ZV1(JI,JJ,JK)
   ZV2V(KK) = ZV2(JI,JJ,JK)
  ENDDO
 ENDDO
ENDDO
MDOT_PRODUCT_3DB = DOT_PRODUCT(ZV1V,ZV2V)
END FUNCTION MDOT_PRODUCT_3DB

REAL(R8) FUNCTION MDOT_PRODUCT_3D(ZV1,ZV2)
IMPLICIT NONE
REAL(R8), INTENT(IN) :: ZV1(JPI,JPJ,JPK)
REAL(R8), INTENT(IN) :: ZV2(JPI,JPJ,JPK)
REAL(R8) :: ZV1V(JPI*JPJ*JPK)
REAL(R8) :: ZV2V(JPI*JPJ*JPK)
INTEGER(I4) :: KK,JI,JJ,JK
KK=0
DO JK=1,JPK
 DO JJ=1,JPJ
  DO JI=1,JPI
   KK=KK+1
   ZV1V(KK) = ZV1(JI,JJ,JK)
   ZV2V(KK) = ZV2(JI,JJ,JK)
  ENDDO
 ENDDO
ENDDO
MDOT_PRODUCT_3D = DOT_PRODUCT(ZV1V,ZV2V)
END FUNCTION MDOT_PRODUCT_3D

REAL(R8) FUNCTION MDOT_PRODUCT_2D(ZV1,ZV2)
IMPLICIT NONE
REAL(R8), INTENT(IN) :: ZV1(JPI,JPJ)
REAL(R8), INTENT(IN) :: ZV2(JPI,JPJ)
REAL(R8) :: ZV1V(JPI*JPJ)
REAL(R8) :: ZV2V(JPI*JPJ)
INTEGER(I4) :: KK,JI,JJ
KK=0
DO JJ=1,JPJ
  DO JI=1,JPI
   KK=KK+1
   ZV1V(KK) = ZV1(JI,JJ)
   ZV2V(KK) = ZV2(JI,JJ)
  ENDDO
ENDDO
MDOT_PRODUCT_2D = DOT_PRODUCT(ZV1V,ZV2V)
END FUNCTION MDOT_PRODUCT_2D

REAL(R8) FUNCTION MDOT_PRODUCT_4(ZV1A,ZV1B,ZV2A,ZV2B)
IMPLICIT NONE
REAL(R8), INTENT(IN) :: ZV1A(JPI,JPJ)
REAL(R8), INTENT(IN) :: ZV1B(JPI,JPJ)
REAL(R8), INTENT(IN) :: ZV2A(JPI,JPJ)
REAL(R8), INTENT(IN) :: ZV2B(JPI,JPJ)
REAL(R8) :: ZV1VA(JPI*JPJ)
REAL(R8) :: ZV1VB(JPI*JPJ)
REAL(R8) :: ZV2VA(JPI*JPJ)
REAL(R8) :: ZV2VB(JPI*JPJ)
INTEGER(I4) :: KK,JI,JJ
KK=0
DO JJ=1,JPJ
  DO JI=1,JPI
   KK=KK+1
   ZV1VA(KK) = ZV1A(JI,JJ)
   ZV1VB(KK) = ZV1B(JI,JJ)
   ZV2VA(KK) = ZV2A(JI,JJ)
   ZV2VB(KK) = ZV2B(JI,JJ)
  ENDDO
ENDDO
MDOT_PRODUCT_4 = DOT_PRODUCT(ZV1VA,ZV2VA)+DOT_PRODUCT(ZV1VB,ZV2VB)
END FUNCTION MDOT_PRODUCT_4

SUBROUTINE RANDOM_FLD_2D(ZVAR,LLWM0)
IMPLICIT NONE
REAL(R8), INTENT(INOUT) :: ZVAR(JPI,JPJ)
REAL(R8) :: ZV(JPI*JPJ)
INTEGER(I4) :: KK,JI,JJ
LOGICAL, OPTIONAL :: LLWM0
LOGICAL :: LLWM = .FALSE.
IF(.NOT. LLINIT_RND) CALL INIT_RND
IF(PRESENT(LLWM0)) THEN
 IF(LLWM0)LLWM=.TRUE.
ENDIF
CALL GAUSSIAN_DISTRIBUTION(ZV,GOLUM)
KK=0
DO JJ=1,JPJ
 DO JI=1,JPI
  KK=KK+1
  ZVAR(JI,JJ) = ZV(KK)*GRD%MSK(JI,JJ,1)
  IF(LL_WEIMULT.OR.LLWM) ZVAR(JI,JJ) = ZVAR(JI,JJ)*E1T(JI,JJ)*E2T(JI,JJ)
 ENDDO
ENDDO
END SUBROUTINE RANDOM_FLD_2D

SUBROUTINE RANDOM_FLD_1D(ZVAR,NN)
IMPLICIT NONE
INTEGER(I4), INTENT(IN) :: NN
REAL(R8), INTENT(INOUT) :: ZVAR(NN)
IF(.NOT. LLINIT_RND) CALL INIT_RND
CALL GAUSSIAN_DISTRIBUTION(ZVAR,GOLUM)
END SUBROUTINE RANDOM_FLD_1D

SUBROUTINE RANDOM_FLD_3D(ZVAR,LLWM0)
IMPLICIT NONE
REAL(R8), INTENT(INOUT) :: ZVAR(JPI,JPJ,JPK)
REAL(R8) :: ZV(JPI*JPJ*JPK)
INTEGER(I4) :: KK,JI,JJ,JK
LOGICAL, OPTIONAL :: LLWM0
LOGICAL :: LLWM = .FALSE.
IF(.NOT. LLINIT_RND) CALL INIT_RND
IF(PRESENT(LLWM0)) THEN
 IF(LLWM0)LLWM=.TRUE.
ENDIF
CALL GAUSSIAN_DISTRIBUTION(ZV,GOLUM)
KK=0
DO JK=1,JPK
 DO JJ=1,JPJ
  DO JI=1,JPI
   KK=KK+1
   ZVAR(JI,JJ,JK) = ZV(KK)*GRD%MSK(JI,JJ,JK)
   IF(LL_WEIMULT) ZVAR(JI,JJ,JK) = ZVAR(JI,JJ,JK)*E1T(JI,JJ)*E2T(JI,JJ)*E3T(JK)
  ENDDO
 ENDDO
ENDDO
END SUBROUTINE RANDOM_FLD_3D

SUBROUTINE RANDOM_FLD_3DB(ZVAR,NI,NJ,NK)
IMPLICIT NONE
INTEGER(I4), INTENT(IN) :: NI,NJ,NK
REAL(R8), INTENT(INOUT) :: ZVAR(NI,NJ,NK)
REAL(R8) :: ZV(NI*NJ*NK)
INTEGER(I4) :: KK,JI,JJ,JK
CALL GAUSSIAN_DISTRIBUTION(ZV,GOLUM)
KK=0
DO JK=1,NK
 DO JJ=1,NJ
  DO JI=1,NI
   KK=KK+1
   ZVAR(JI,JJ,JK) = ZV(KK)
  ENDDO
 ENDDO
ENDDO
END SUBROUTINE RANDOM_FLD_3DB


SUBROUTINE RANDOM_FLD_4D(ZVAR,NI,NJ,NK,NT,LLWM0)
IMPLICIT NONE
INTEGER(I4), INTENT(IN) :: NI,NJ,NK,NT
REAL(R8), INTENT(INOUT) :: ZVAR(NI,NJ,NK,NT)
REAL(R8) :: ZV(NI*NJ*NK*NT)
INTEGER(I4) :: KK,JI,JJ,JK,JT
LOGICAL, OPTIONAL :: LLWM0
LOGICAL :: LLWM = .FALSE.
IF(.NOT. LLINIT_RND) CALL INIT_RND
IF(PRESENT(LLWM0)) THEN
 IF(LLWM0)LLWM=.TRUE.
ENDIF
CALL GAUSSIAN_DISTRIBUTION(ZV,GOLUM)
KK=0
DO JT=1,NT
DO JK=1,NK
 DO JJ=1,NJ
  DO JI=1,NI
   KK=KK+1
   ZVAR(JI,JJ,JK,JT) = ZV(KK)
   IF(LL_WEIMULT) ZVAR(JI,JJ,JK,JT) = ZVAR(JI,JJ,JK,JT)*E1T(JI,JJ)*E2T(JI,JJ)*E3T(JK)
  ENDDO
 ENDDO
ENDDO
ENDDO
END SUBROUTINE RANDOM_FLD_4D

SUBROUTINE INIT_RND
IMPLICIT NONE
INTEGER(I4) :: KSEED
CALL SYSTEM_CLOCK(COUNT=KSEED)
CALL INITIALIZE_RANDOM_NUMBERS(KSEED,GOLUM)
LLINIT_RND = .TRUE.
END SUBROUTINE INIT_RND

CHARACTER(LEN=8) FUNCTION TEST_RES(ZE,ZEPS0)
IMPLICIT NONE
REAL(R8), INTENT(IN) :: ZE,ZEPS0
REAL(R8) :: ZEPS
ZEPS=SQRT(ZEPS0)
TEST_RES = 'UNDEFIN '
IF(ZE.LE.ZEPS) TEST_RES = 'OK      '
IF(ZE.GT.ZEPS.AND.ZE.LE.100._R8*ZEPS) TEST_RES = 'WARNING '
IF(ZE.GT.100._R8*ZEPS) TEST_RES = 'FAILED  '
END FUNCTION TEST_RES

END MODULE ADTEST
