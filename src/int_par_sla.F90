SUBROUTINE INT_PAR_SLA

!-----------------------------------------------------------------------
!                                                                      !
! GET INTERPOLATION PARAMETERS FOR A GRID                              !
!                                                                      !
! VERSION 1: S.DOBRICIC 2006                                           !
!-----------------------------------------------------------------------

 USE SET_KND
 USE GRD_STR
 USE PHINTERP2
#ifndef NECSX
! USE PHINTERP
#endif
 USE RUN
 USE OBS_STR
 USE MYFRTPROF, ONLY : MYFRTPROF_WALL
 USE MYNETCDF
 USE OBSHANDLING
 USE IOUNITS

 IMPLICIT NONE

  INTEGER(I4)   ::  K, N_TOPEX, N_ERS, II, JJ,I2
  INTEGER(I4)   ::  I1, J1, KK, I, J, ITER, IAUX, JP
  INTEGER(I4)   ::  MSCOUNT
  REAL(R8)      ::  P1, Q1, P, Q, SUMT, SUMI, TIMP,NEWLON
  REAL(R8)      ::  MSK4, ZZSS, ZC
  REAL(R8), ALLOCATABLE :: ZSLAC(:,:)

#include "obs_events.h"

 CALL MYFRTPROF_WALL('INT_PAR_SLA: SLA INTERPOLATION',0)

 IF(SLA%NO.EQ.0) THEN
   CALL MYFRTPROF_WALL('INT_PAR_SLA: SLA INTERPOLATION',1)
   RETURN
 ENDIF

 IF( LL_SLA_CORRECTIVE_MAP ) THEN
    ALLOCATE( ZSLAC(GRD%IM,GRD%JM) )
    CALL GETNCVAR('SLA_CORR.nc','sla',GRD%IM, GRD%JM, ZSLAC )
    WRITE(IOUNLOG,*) ' CORRECTIVE MAP FOR SLA  -  FILE SLA_CORR.nc'
 ENDIF

!#ifdef NECSX
 CALL PREPINTERP_INIT
!#endif

 SLA%FLC = 0
 SLA%IB  = 0
 SLA%JB  = 0
 SLA%DPT = 0._R8
 SLA%TDIST(1:SLA%NO)=SLA%TIM(1:SLA%NO) - ZANJUL1950

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(KK)
!$OMP DO SCHEDULE(DYNAMIC)
#endif
CYOBS0 : DO KK = 1,SLA%NO

      IF( SLA%EVE(KK) .EQ. KEVE_PDOM ) CYCLE CYOBS0

#ifdef NECSX
      CALL PREPINTERP2(SLA%LON(KK),SLA%LAT(KK),SLA%IB(KK,:),SLA%JB(KK,:),SLA%PQ(KK,:))
#else
!      IF( NN_INTERPM .EQ. 1 ) THEN
!         CALL PREPINTERP(SLA%LON(KK),SLA%LAT(KK),SLA%IB(KK,:),SLA%JB(KK,:),SLA%PQ(KK,:))
!      ELSEIF ( NN_INTERPM .EQ. 2 ) THEN
         CALL PREPINTERP2(SLA%LON(KK),SLA%LAT(KK),SLA%IB(KK,:),SLA%JB(KK,:),SLA%PQ(KK,:))
!      ENDIF
#endif

ENDDO CYOBS0
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

#ifdef SHARED_MEMORY
!$OMP PARALLEL DEFAULT(SHARED), PRIVATE(KK,ZZSS,JP,MSK4)
!$OMP DO SCHEDULE(DYNAMIC)
#endif
CYOBS : DO KK = 1,SLA%NO
       IF( ALL(SLA%IB(KK,:).GE.1 ) .AND. ALL(SLA%JB(KK,:).GE.1 ) .AND. &
       & ALL(SLA%IB(KK,:).LE.GRD%IM ) .AND. ALL(SLA%JB(KK,:).LE.GRD%JM ) ) THEN
          SLA%FLC(KK) = 1
       ELSE
          SLA%FLC(KK) = 0
          SLA%EVE(KK) = KEVE_INTE
          CYCLE CYOBS
       ENDIF

       SLA%PQ(KK,1) = SLA%PQ(KK,1) * GRD%MSK(SLA%IB(KK,1),SLA%JB(KK,1),1)
       SLA%PQ(KK,2) = SLA%PQ(KK,2) * GRD%MSK(SLA%IB(KK,2),SLA%JB(KK,2),1)
       SLA%PQ(KK,3) = SLA%PQ(KK,3) * GRD%MSK(SLA%IB(KK,3),SLA%JB(KK,3),1)
       SLA%PQ(KK,4) = SLA%PQ(KK,4) * GRD%MSK(SLA%IB(KK,4),SLA%JB(KK,4),1)

       ZZSS = 0._R8
       DO JP=1,NPQ
         ZZSS = ZZSS + GRD%MSK(SLA%IB(KK,JP),SLA%JB(KK,JP),1)
       ENDDO

       IF( ABS( ZZSS ) .LT. 1._R8 ) THEN
           SLA%FLC(KK) = 0
           SLA%EVE(KK) = KEVE_MASK
           CYCLE CYOBS
       ELSE
           SLA%PQ(KK,:) = SLA%PQ(KK,:) / SUM(SLA%PQ(KK,:))
       ENDIF

       MSK4=0._R8
       DO JP=1,NPQ
           SLA%DPT(KK) = MAX( SLA%DPT(KK),GRD%HGT(SLA%IB(KK,JP),SLA%JB(KK,JP)) )
           MSK4=MSK4+GRD%MSK(SLA%IB(KK,JP),SLA%JB(KK,JP),SLA%KDP)
       ENDDO

       IF(MSK4 .LT. 1._R8) THEN
           SLA%FLC(KK) = 0
           SLA%EVE(KK) = KEVE_MASK
       ENDIF

       IF( SLA%FLC(KK) .EQ. 1 .AND. LL_SLA_CORRECTIVE_MAP ) THEN
         ZC = OSUM( SLA%PQ(KK,1:NPQ),ZSLAC(SLA%IB(KK,1:NPQ),SLA%JB(KK,1:NPQ) ) )
         SLA%VAL(KK) = SLA%VAL(KK) - ZC
       ENDIF

ENDDO CYOBS
#ifdef SHARED_MEMORY
!$OMP END DO
!$OMP END PARALLEL
#endif

MSCOUNT=COUNT(SLA%EVE(1:SLA%NO).EQ.KEVE_INTE)
WRITE(IOUNLOG,*) &
& ' SLA OBS FILTERED OUT FOR INTERP PROBLEMS: ',MSCOUNT

MSCOUNT=COUNT(SLA%EVE(1:SLA%NO).EQ.KEVE_MASK)
WRITE(IOUNLOG,*) &
& ' SLA OBS FILTERED OUT FOR MASKING INCONSISTENCIES: ',MSCOUNT

! ---
! COUNT GOOD OBSERVATIONS
  SLA%NC = COUNT(SLA%FLC(1:SLA%NO) .EQ. 1)

  WRITE(IOUNLOG,*)
  WRITE(IOUNLOG,*) ' *** SLA OBS AFTER INTERPOLATION SET-UP'
  WRITE(IOUNLOG,*) ' TOTAL NUMBER OF SLA OBS           :',SLA%NO
  WRITE(IOUNLOG,*) ' TOTAL NUMBER OF RETAINED SLA  OBS :',SLA%NC

 IF( LL_SLA_CORRECTIVE_MAP ) DEALLOCATE( ZSLAC )

CALL MYFRTPROF_WALL('INT_PAR_SLA: SLA INTERPOLATION',1)
END SUBROUTINE INT_PAR_SLA
