!$ID: CALENDAR.F90 238 2008-01-23 15:53:27Z BELLIER $
!-
MODULE CALENDAR
!!!A.S.: ADDED EXPLICIT KIND OF ALL THE VARS
!---------------------------------------------------------------------
!- THIS IS THE CALENDAR WHICH GOING TO BE USED TO DO ALL
!- CALCULATIONS ON TIME. THREE TYPES OF CALENDARS ARE POSSIBLE :
!-
!-  - GREGORIAN :
!-      THE NORMAL CALENDAR. THE TIME ORIGIN FOR THE
!-      JULIAN DAY IN THIS CASE IS 24 NOV -4713
!-      (OTHER NAMES : 'STANDARD','PROLEPTIC_GREGORIAN')
!-  - NOLEAP :
!-      A 365 DAY YEAR WITHOUT LEAP YEARS.
!-      THE ORIGIN FOR THE JULIAN DAYS IS IN THIS CASE 1 JAN 0
!-      (OTHER NAMES : '365_DAY','365D')
!-  - ALL_LEAP :
!-      A 366 DAY YEAR WITH LEAP YEARS.
!-      THE ORIGIN FOR THE JULIAN DAYS IS IN THIS CASE ????
!-      (OTHER NAMES : '366_DAY','366D'
!-  - JULIAN :
!-      SAME AS GREGORIAN, BUT WITH ALL LEAP CENTURY YEARS
!-  - XXXD :
!-      YEAR OF XXX DAYS WITH MONTH OF EQUAL LENGTH.
!-      THE ORIGIN FOR THE JULIAN DAYS IS THEN ALSO 1 JAN 0
!-
!- AS ONE CAN SEE IT IS DIFFICULT TO GO FROM ONE CALENDAR TO THE OTHER.
!- ALL OPERATIONS INVOLVING JULIAN DAYS WILL BE WRONG.
!- THIS CALENDAR WILL LOCK AS SOON AS POSSIBLE
!- THE LENGTH OF THE YEAR AND FORBID ANY FURTHER MODIFICATION.
!-
!- FOR THE NON LEAP-YEAR CALENDAR THE METHOD IS STILL BRUTE FORCE.
!- WE NEED TO FIND AN INTEGER SERIES WHICH TAKES CARE OF THE LENGTH
!- OF THE VARIOUS MONTH. (JAN)
!-
!-   ONE_DAY  : ONE DAY IN SECONDS
!-   ONE_YEAR : ONE YEAR IN DAYS
!---------------------------------------------------------------------
  USE STRINGOP,ONLY  : STRUPPERCASE
  USE ERRIOIPSL,ONLY : IPSLERR
  USE SET_KND
!-
  PRIVATE
  PUBLIC :: YMDS2JU,JU2YMDS,TLEN2ITAU,ISITTIME,IOCONF_CALENDAR, &
 &          IOGET_CALENDAR,IOGET_MON_LEN,ITAU2DATE,IOGET_TIMESTAMP, &
 &          IOCONF_STARTDATE,ITAU2YMDS,TIME_DIFF,TIME_ADD, &
 &          LOCK_CALENDAR
!-
  INTERFACE IOGET_CALENDAR
    MODULE PROCEDURE &
 &    IOGET_CALENDAR_REAL1,IOGET_CALENDAR_REAL2,IOGET_CALENDAR_STR
  END INTERFACE
!-
  INTERFACE IOCONF_STARTDATE
     MODULE PROCEDURE &
 &    IOCONF_STARTDATE_SIMPLE,IOCONF_STARTDATE_INTERNAL, &
 &    IOCONF_STARTDATE_YMDS
  END INTERFACE
!-
  REAL(KIND=DP),PARAMETER :: ONE_DAY = 86400.0
  LOGICAL,SAVE :: LOCK_STARTDATE = .FALSE.
!-
  CHARACTER(LEN=30),SAVE :: TIME_STAMP='XXXXXXXXXXXXXXXX'
!-
!- DESCRIPTION OF CALENDAR
!-
  CHARACTER(LEN=20),SAVE :: CALENDAR_USED="GREGORIAN"
  LOGICAL,SAVE :: LOCK_ONE_YEAR = .FALSE.
  REAL(KIND=DP),SAVE :: ONE_YEAR = 365.2425_DP
  INTEGER(KIND=I4),SAVE :: MON_LEN(12)=(/31,28,31,30,31,30,31,31,30,31,30,31/)
!-
  CHARACTER(LEN=3),PARAMETER :: &
 &  CAL(12) = (/'JAN','FEB','MAR','APR','MAY','JUN', &
 &              'JUL','AUG','SEP','OCT','NOV','DEC'/)
!-
  REAL(KIND=DP),SAVE :: START_DAY,START_SEC
!-
CONTAINS
!-
!===
!-
SUBROUTINE LOCK_CALENDAR (NEW_STATUS,OLD_STATUS)
!!--------------------------------------------------------------------
!! THE "LOCK_CALENDAR" ROUTINE
!! ALLOWS TO LOCK OR UNLOCK THE CALENDAR,
!! AND TO KNOW THE CURRENT STATUS OF THE CALENDAR.
!! BE CAREFUL !
!!
!! SUBROUTINE LOCK_CALENDAR (NEW_STATUS,OLD_STATUS)
!!
!! OPTIONAL INPUT ARGUMENT
!!
!! (L) NEW_STATUS : NEW STATUS OF THE CALENDAR
!!
!! OPTIONAL OUTPUT ARGUMENT
!!
!! (L) OLD_STATUS : CURRENT STATUS OF THE CALENDAR
!!--------------------------------------------------------------------
  IMPLICIT NONE
!-
  LOGICAL,OPTIONAL,INTENT(IN)  :: NEW_STATUS
  LOGICAL,OPTIONAL,INTENT(OUT) :: OLD_STATUS
!---------------------------------------------------------------------
  IF (PRESENT(OLD_STATUS)) THEN
    OLD_STATUS = LOCK_ONE_YEAR
  ENDIF
  IF (PRESENT(NEW_STATUS)) THEN
    LOCK_ONE_YEAR = NEW_STATUS
  ENDIF
!---------------------------
END SUBROUTINE LOCK_CALENDAR
!-
!===
!-
SUBROUTINE YMDS2JU (YEAR,MONTH,DAY,SEC,JULIAN)
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: YEAR,MONTH,DAY
  REAL(KIND=DP),INTENT(IN)    :: SEC
!-
  REAL(KIND=DP),INTENT(OUT) :: JULIAN
!-
  INTEGER(KIND=I4) :: JULIAN_DAY
  REAL(KIND=DP)    :: JULIAN_SEC
!---------------------------------------------------------------------
  CALL YMDS2JU_INTERNAL (YEAR,MONTH,DAY,SEC,JULIAN_DAY,JULIAN_SEC)
!-
  JULIAN = JULIAN_DAY+JULIAN_SEC/ONE_DAY
!---------------------
END SUBROUTINE YMDS2JU
!-
!===
!-
SUBROUTINE YMDS2JU_INTERNAL (YEAR,MONTH,DAY,SEC,JULIAN_DAY,JULIAN_SEC)
!---------------------------------------------------------------------
!- CONVERTS YEAR, MONTH, DAY AND SECONDS INTO A JULIAN DAY
!-
!- IN 1968 IN A LETTER TO THE EDITOR OF COMMUNICATIONS OF THE ACM
!- (CACM, VOLUME 11, NUMBER 10, OCTOBER 1968, P.657) HENRY F. FLIEGEL
!- AND THOMAS C. VAN FLANDERN PRESENTED SUCH AN ALGORITHM.
!-
!- SEE ALSO : HTTP://WWW.MAGNET.CH/SERENDIPITY/HERMETIC/CAL_STUD/JDN.HTM
!-
!- IN THE CASE OF THE GREGORIAN CALENDAR WE HAVE CHOSEN TO USE
!- THE LILIAN DAY NUMBERS. THIS IS THE DAY COUNTER WHICH STARTS
!- ON THE 15TH OCTOBER 1582.
!- THIS IS THE DAY AT WHICH POPE GREGORY XIII INTRODUCED THE
!- GREGORIAN CALENDAR.
!- COMPARED TO THE TRUE JULIAN CALENDAR, WHICH STARTS SOME
!- 7980 YEARS AGO, THE LILIAN DAYS ARE SMALER AND ARE DEALT WITH
!- EASILY ON 32 BIT MACHINES. WITH THE TRUE JULIAN DAYS YOU CAN ONLY
!- THE FRACTION OF THE DAY IN THE REAL PART TO A PRECISION OF
!- A 1/4 OF A DAY WITH 32 BITS.
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: YEAR,MONTH,DAY
  REAL(KIND=DP),INTENT(IN)    :: SEC
!-
  INTEGER(KIND=I4),INTENT(OUT) :: JULIAN_DAY
  REAL(KIND=DP),INTENT(OUT)    :: JULIAN_SEC
!-
  INTEGER(KIND=I4) :: JD,M,Y,D,ML
!---------------------------------------------------------------------
  LOCK_ONE_YEAR = .TRUE.
!-
  M = MONTH
  Y = YEAR
  D = DAY
!-
!- WE DEDUCE THE CALENDAR FROM THE LENGTH OF THE YEAR AS IT
!- IS FASTER THAN AN INDEX ON THE CALENDAR VARIABLE.
!-
  IF ( (ONE_YEAR > 365.0).AND.(ONE_YEAR < 366.0) ) THEN
!-- "GREGORIAN"
    JD = (1461*(Y+4800+INT((M-14)/12)))/4 &
 &      +(367*(M-2-12*(INT((M-14)/12))))/12 &
 &      -(3*((Y+4900+INT((M-14)/12))/100))/4 &
 &      +D-32075
    JD = JD-2299160
  ELSE IF (    (ABS(ONE_YEAR-365.0) <= EPSILON(ONE_YEAR))  &
 &         .OR.(ABS(ONE_YEAR-366.0) <= EPSILON(ONE_YEAR)) ) THEN
!-- "NO LEAP" OR "ALL LEAP"
    ML = SUM(MON_LEN(1:M-1))
    JD = Y*NINT(ONE_YEAR)+ML+(D-1)
  ELSE
!-- CALENDAR WITH REGULAR MONTH
    ML = NINT(ONE_YEAR/12.)
    JD = Y*NINT(ONE_YEAR)+(M-1)*ML+(D-1)
  ENDIF
!-
  JULIAN_DAY = JD
  JULIAN_SEC = SEC
!------------------------------
END SUBROUTINE YMDS2JU_INTERNAL
!-
!===
!-
SUBROUTINE JU2YMDS (JULIAN,YEAR,MONTH,DAY,SEC)
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  REAL(KIND=DP),INTENT(IN) :: JULIAN
!-
  INTEGER(KIND=I4),INTENT(OUT) :: YEAR,MONTH,DAY
  REAL(KIND=DP),INTENT(OUT)    :: SEC
!-
  INTEGER(KIND=I4) :: JULIAN_DAY
  REAL(KIND=DP)    :: JULIAN_SEC
!---------------------------------------------------------------------
  JULIAN_DAY = INT(JULIAN)
  JULIAN_SEC = (JULIAN-JULIAN_DAY)*ONE_DAY
!-
  CALL JU2YMDS_INTERNAL(JULIAN_DAY,JULIAN_SEC,YEAR,MONTH,DAY,SEC)
!---------------------
END SUBROUTINE JU2YMDS
!-
!===
!-
SUBROUTINE JU2YMDS_INTERNAL (JULIAN_DAY,JULIAN_SEC,YEAR,MONTH,DAY,SEC)
!---------------------------------------------------------------------
!- THIS SUBROUTINE COMPUTES FROM THE JULIAN DAY THE YEAR,
!- MONTH, DAY AND SECONDS
!-
!- IN 1968 IN A LETTER TO THE EDITOR OF COMMUNICATIONS OF THE ACM
!- (CACM, VOLUME 11, NUMBER 10, OCTOBER 1968, P.657) HENRY F. FLIEGEL
!- AND THOMAS C. VAN FLANDERN PRESENTED SUCH AN ALGORITHM.
!-
!- SEE ALSO : HTTP://WWW.MAGNET.CH/SERENDIPITY/HERMETIC/CAL_STUD/JDN.HTM
!-
!- IN THE CASE OF THE GREGORIAN CALENDAR WE HAVE CHOSEN TO USE
!- THE LILIAN DAY NUMBERS. THIS IS THE DAY COUNTER WHICH STARTS
!- ON THE 15TH OCTOBER 1582. THIS IS THE DAY AT WHICH POPE
!- GREGORY XIII INTRODUCED THE GREGORIAN CALENDAR.
!- COMPARED TO THE TRUE JULIAN CALENDAR, WHICH STARTS SOME 7980
!- YEARS AGO, THE LILIAN DAYS ARE SMALER AND ARE DEALT WITH EASILY
!- ON 32 BIT MACHINES. WITH THE TRUE JULIAN DAYS YOU CAN ONLY THE
!- FRACTION OF THE DAY IN THE REAL PART TO A PRECISION OF A 1/4 OF
!- A DAY WITH 32 BITS.
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: JULIAN_DAY
  REAL(KIND=DP),INTENT(IN)    :: JULIAN_SEC
!-
  INTEGER(KIND=I4),INTENT(OUT) :: YEAR,MONTH,DAY
  REAL(KIND=DP),INTENT(OUT)    :: SEC
!-
  INTEGER(KIND=I4) :: L,N,I,JD,J,D,M,Y,ML
  INTEGER(KIND=I4) :: ADD_DAY
  REAL(KIND=DP) :: EPS_DAY
!---------------------------------------------------------------------
  EPS_DAY = SPACING(ONE_DAY)
  LOCK_ONE_YEAR = .TRUE.
!-
  JD = JULIAN_DAY
  SEC = JULIAN_SEC
  IF (SEC > (ONE_DAY-EPS_DAY)) THEN
    ADD_DAY = INT(SEC/ONE_DAY)
    SEC = SEC-ADD_DAY*ONE_DAY
    JD = JD+ADD_DAY
  ENDIF
  IF (SEC < -EPS_DAY) THEN
    SEC = SEC+ONE_DAY
    JD = JD-1
  ENDIF
!-
  IF ( (ONE_YEAR > 365.0).AND.(ONE_YEAR < 366.0) ) THEN
!-- GREGORIAN
    JD = JD+2299160
!-
    L = JD+68569
    N = (4*L)/146097
    L = L-(146097*N+3)/4
    I = (4000*(L+1))/1461001
    L = L-(1461*I)/4+31
    J = (80*L)/2447
    D = L-(2447*J)/80
    L = J/11
    M = J+2-(12*L)
    Y = 100*(N-49)+I+L
  ELSE IF (    (ABS(ONE_YEAR-365.0) <= EPSILON(ONE_YEAR)) &
 &         .OR.(ABS(ONE_YEAR-366.0) <= EPSILON(ONE_YEAR)) ) THEN
!-- NO LEAP OR ALL LEAP
    Y = JD/NINT(ONE_YEAR)
    L = JD-Y*NINT(ONE_YEAR)
    M = 1
    ML = 0
    DO WHILE (ML+MON_LEN(M) <= L)
      ML = ML+MON_LEN(M)
      M = M+1
    ENDDO
    D = L-ML+1
  ELSE
!-- OTHERS
    ML = NINT(ONE_YEAR/12.)
    Y = JD/NINT(ONE_YEAR)
    L = JD-Y*NINT(ONE_YEAR)
    M = (L/ML)+1
    D = L-(M-1)*ML+1
  ENDIF
!-
  DAY = D
  MONTH = M
  YEAR = Y
!------------------------------
END SUBROUTINE JU2YMDS_INTERNAL
!-
!===
!-
SUBROUTINE TLEN2ITAU (INPUT_STR,DT,DATE,ITAU)
!---------------------------------------------------------------------
!- THIS SUBROUTINE TRANSFORMS A STRING CONTAINING A TIME LENGTH
!- INTO A NUMBER OF TIME STEPS.
!- TO DO THIS OPERATION THE DATE (IN JULIAN DAYS IS NEEDED AS THE
!- LENGTH OF THE MONTH VARIES.
!- THE FOLLOWING CONVENTION IS USED :
!-   N   : N TIME STEPS
!-   NS  : N SECONDS IS TRANSFORMED INTO ITAUS
!-   NH  : N HOURS
!-   ND  : N DAYS
!-   NM  : N MONTH
!-   NY  : N YEARS
!- COMBINATIONS ARE ALSO POSSIBLE
!-   NYMD : NYEARS PLUS M DAYS !
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  CHARACTER(LEN=*),INTENT(IN) :: INPUT_STR
  REAL(KIND=DP),INTENT(IN)             :: DT,DATE
!-
  INTEGER(KIND=I4),INTENT(OUT)         :: ITAU
!-
  INTEGER(KIND=I4)           :: Y_POS,M_POS,D_POS,H_POS,S_POS
  INTEGER(KIND=I4)           :: READ_TIME
  CHARACTER(LEN=13) :: FMT
  CHARACTER(LEN=80) :: TMP_STR
!-
  INTEGER(KIND=I4) :: YEAR,MONTH,DAY
  REAL(KIND=DP)    :: SEC,DATE_NEW,DD,SS
!---------------------------------------------------------------------
  ITAU = 0
  CALL JU2YMDS (DATE,YEAR,MONTH,DAY,SEC)
!-
  Y_POS = MAX(INDEX(INPUT_STR,'Y'),INDEX(INPUT_STR,'Y'))
  M_POS = MAX(INDEX(INPUT_STR,'M'),INDEX(INPUT_STR,'M'))
  D_POS = MAX(INDEX(INPUT_STR,'D'),INDEX(INPUT_STR,'D'))
  H_POS = MAX(INDEX(INPUT_STR,'H'),INDEX(INPUT_STR,'H'))
  S_POS = MAX(INDEX(INPUT_STR,'S'),INDEX(INPUT_STR,'S'))
!-
  IF (MAX(Y_POS,M_POS,D_POS,S_POS) > 0) THEN
    TMP_STR = INPUT_STR
    DO WHILE ( MAX(Y_POS,M_POS,D_POS,S_POS) > 0)
!---- WRITE(*,*) TMP_STR
!---- WRITE(*,*) Y_POS,M_POS,D_POS,S_POS
      IF (Y_POS > 0) THEN
        WRITE(FMT,'("(I",I10.10,")")') Y_POS-1
        READ(TMP_STR(1:Y_POS-1),FMT) READ_TIME
        CALL YMDS2JU (YEAR+READ_TIME,MONTH,DAY,SEC,DATE_NEW)
        DD = DATE_NEW-DATE
        SS = INT(DD)*ONE_DAY+DD-INT(DD)
        ITAU = ITAU+NINT(SS/DT)
        TMP_STR = TMP_STR(Y_POS+1:LEN_TRIM(TMP_STR))
      ELSE IF (M_POS > 0) THEN
        WRITE(FMT,'("(I",I10.10,")")') M_POS-1
        READ(TMP_STR(1:M_POS-1),FMT) READ_TIME
        CALL YMDS2JU (YEAR,MONTH+READ_TIME,DAY,SEC,DATE_NEW)
        DD = DATE_NEW-DATE
        SS = INT(DD)*ONE_DAY+DD-INT(DD)
        ITAU = ITAU+NINT(SS/DT)
        TMP_STR = TMP_STR(M_POS+1:LEN_TRIM(TMP_STR))
      ELSE IF (D_POS > 0) THEN
        WRITE(FMT,'("(I",I10.10,")")') D_POS-1
        READ(TMP_STR(1:D_POS-1),FMT) READ_TIME
        ITAU = ITAU+NINT(READ_TIME*ONE_DAY/DT)
        TMP_STR = TMP_STR(D_POS+1:LEN_TRIM(TMP_STR))
      ELSE IF (H_POS > 0) THEN
        WRITE(FMT,'("(I",I10.10,")")') H_POS-1
        READ(TMP_STR(1:H_POS-1),FMT) READ_TIME
        ITAU = ITAU+NINT(READ_TIME*60.*60./DT)
        TMP_STR = TMP_STR(D_POS+1:LEN_TRIM(TMP_STR))
      ELSE IF  (S_POS > 0) THEN
        WRITE(FMT,'("(I",I10.10,")")') S_POS-1
        READ(TMP_STR(1:S_POS-1),FMT) READ_TIME
        ITAU = ITAU+NINT(READ_TIME/DT)
        TMP_STR = TMP_STR(S_POS+1:LEN_TRIM(TMP_STR))
      ENDIF
!-
      Y_POS = MAX(INDEX(TMP_STR,'Y'),INDEX(TMP_STR,'Y'))
      M_POS = MAX(INDEX(TMP_STR,'M'),INDEX(TMP_STR,'M'))
      D_POS = MAX(INDEX(TMP_STR,'D'),INDEX(TMP_STR,'D'))
      H_POS = MAX(INDEX(TMP_STR,'H'),INDEX(TMP_STR,'H'))
      S_POS = MAX(INDEX(TMP_STR,'S'),INDEX(TMP_STR,'S'))
    ENDDO
  ELSE
    WRITE(FMT,'("(I",I10.10,")")') LEN_TRIM(INPUT_STR)
    READ(INPUT_STR(1:LEN_TRIM(INPUT_STR)),FMT) ITAU
  ENDIF
!-----------------------
END SUBROUTINE TLEN2ITAU
!-
!===
!-
REAL(KIND=DP) FUNCTION ITAU2DATE (ITAU,DATE0,DELTAT)
!---------------------------------------------------------------------
!- THIS FUNCTION TRANSFORMS ITAU INTO A DATE. THE DATE WITH WHICH
!- THE TIME AXIS IS GOING TO BE LABELED
!-
!- INPUT
!-   ITAU   : CURRENT TIME STEP
!-   DATE0  : DATE AT WHICH ITAU WAS EQUAL TO 0
!-   DELTAT : TIME STEP BETWEEN ITAU S
!-
!- OUTPUT
!-   ITAU2DATE : DATE FOR THE GIVEN ITAU
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4)  :: ITAU
  REAL(KIND=DP)     :: DATE0,DELTAT
!---------------------------------------------------------------------
  ITAU2DATE = REAL(ITAU,KIND=DP)*DELTAT/ONE_DAY+DATE0
!---------------------
END FUNCTION ITAU2DATE
!-
!===
!-
SUBROUTINE ITAU2YMDS (ITAU,DELTAT,YEAR,MONTH,DAY,SEC)
!---------------------------------------------------------------------
!- THIS SUBROUTINE TRANSFORMS ITAU INTO A DATE. THE DATE WITH WHICH
!- THE TIME AXIS IS GOING TO BE LABELED
!-
!- INPUT
!-   ITAU   : CURRENT TIME STEP
!-   DELTAT : TIME STEP BETWEEN ITAU S
!-
!- OUTPUT
!-   YEAR  : YEAR
!-   MONTH : MONTH
!-   DAY   : DAY
!-   SEC   : SECONDS SINCE MIDNIGHT
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: ITAU
  REAL(KIND=DP),INTENT(IN)    :: DELTAT
!-
  INTEGER(KIND=I4),INTENT(OUT) :: YEAR,MONTH,DAY
  REAL(KIND=DP),INTENT(OUT)    :: SEC
!-
  INTEGER(KIND=I4) :: JULIAN_DAY
  REAL(KIND=DP)    :: JULIAN_SEC
!---------------------------------------------------------------------
  IF (.NOT.LOCK_STARTDATE) THEN
    CALL IPSLERR (2,'ITAU2YMDS', &
 &   'YOU TRY TO CALL THIS FUNCTION, ITAU2YMDS, BUT YOU DIDN''T', &
 &   ' CALL IOCONF_STARTDATE TO INITIALIZE DATE0 IN CALENDAR.', &
 &   ' PLEASE CALL IOCONF_STARTDATE BEFORE ITAU2YMDS.')
  ENDIF
  JULIAN_DAY = START_DAY
  JULIAN_SEC = START_SEC+REAL(ITAU,KIND=DP)*DELTAT
  CALL JU2YMDS_INTERNAL (JULIAN_DAY,JULIAN_SEC,YEAR,MONTH,DAY,SEC)
!-----------------------
END SUBROUTINE ITAU2YMDS
!-
!===
!-
REAL(KIND=DP) FUNCTION DTCHDATE (ITAU,DATE0,OLD_DT,NEW_DT)
!---------------------------------------------------------------------
!- THIS FUNCTION CHANGES THE DATE SO THAT THE SIMULATION CAN
!- CONTINUE WITH THE SAME ITAU BUT A DIFFERENT DT.
!-
!- INPUT
!-   ITAU   : CURRENT TIME STEP
!-   DATE0  : DATE AT WHICH ITAU WAS EQUAL TO 0
!-   OLD_DT : OLD TIME STEP BETWEEN ITAUS
!-   NEW_DT : NEW TIME STEP BETWEEN ITAUS
!-
!- OUTPUT
!-   DTCHDATE : DATE FOR THE GIVEN ITAU
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: ITAU
  REAL(KIND=DP),INTENT(IN)    :: DATE0,OLD_DT,NEW_DT
!-
  REAL(KIND=DP) :: RTIME
!---------------------------------------------------------------------
  RTIME = ITAU2DATE (ITAU,DATE0,OLD_DT)
  DTCHDATE = RTIME-REAL(ITAU,KIND=DP)*NEW_DT/ONE_DAY
!--------------------
END FUNCTION DTCHDATE
!-
!===
!-
SUBROUTINE ISITTIME &
 &  (ITAU,DATE0,DT,FREQ,LAST_ACTION,LAST_CHECK,DO_ACTION)
!---------------------------------------------------------------------
!- THIS SUBROUTINE CHECKS THE TIME AS COME FOR A GIVEN ACTION.
!- THIS IS COMPUTED FROM THE CURRENT TIME-STEP(ITAU).
!- THUS WE NEED TO HAVE THE TIME DELTA (DT), THE FREQUENCY
!- OF THE ACTION (FREQ) AND THE LAST TIME IT WAS DONE
!- (LAST_ACTION IN UNITS OF ITAU).
!- IN ORDER TO EXTRAPOLATE WHEN WILL BE THE NEXT CHECK WE NEED
!- THE TIME STEP OF THE LAST CALL (LAST_CHECK).
!-
!- THE TEST IS DONE ON THE FOLLOWING CONDITION :
!- THE DISTANCE FROM THE CURRENT TIME TO THE TIME FOR THE NEXT
!- ACTION IS SMALLER THAN THE ONE FROM THE NEXT EXPECTED
!- CHECK TO THE NEXT ACTION.
!- WHEN THE TEST IS DONE ON THE TIME STEPS SIMPLIFACTIONS MAKE
!- IT MORE DIFFICULT TO READ IN THE CODE.
!- FOR THE REAL TIME CASE IT IS EASIER TO UNDERSTAND !
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: ITAU
  REAL(KIND=DP),INTENT(IN)    :: DT,FREQ
  INTEGER(KIND=I4),INTENT(IN) :: LAST_ACTION,LAST_CHECK
  REAL(KIND=DP),INTENT(IN)    :: DATE0
!-
  LOGICAL,INTENT(OUT)  :: DO_ACTION
!-
  REAL(KIND=DP) :: DT_ACTION,DT_CHECK
  REAL(KIND=DP) :: DATE_LAST_ACT,DATE_NEXT_CHECK,DATE_NEXT_ACT, &
 &        DATE_NOW,DATE_MP1,DATE_MPF
  INTEGER(KIND=I4) :: YEAR,MONTH,MONTHP1,DAY,NEXT_CHECK_ITAU,NEXT_ACT_ITAU
  INTEGER(KIND=I4) :: YEARP,DAYP
  REAL(KIND=DP) :: SEC,SECP
  LOGICAL :: CHECK = .FALSE.
!---------------------------------------------------------------------
  IF (CHECK) THEN
    WRITE(*,*) &
 &    "ISITTIME 1.0 ",ITAU,DATE0,DT,FREQ,LAST_ACTION,LAST_CHECK
  ENDIF
!-
  IF (LAST_CHECK >= 0) THEN
    DT_ACTION = (ITAU-LAST_ACTION)*DT
    DT_CHECK = (ITAU-LAST_CHECK)*DT
    NEXT_CHECK_ITAU = ITAU+(ITAU-LAST_CHECK)
!-
!-- WE ARE DEALING WITH FREQUENCIES IN SECONDS AND THUS OPERATION
!-- CAN BE DONE ON THE TIME STEPS.
!-
    IF (FREQ > 0) THEN
      IF (ABS(DT_ACTION-FREQ) <= ABS(DT_ACTION+DT_CHECK-FREQ)) THEN
        DO_ACTION = .TRUE.
      ELSE
        DO_ACTION = .FALSE.
      ENDIF
!-
!---- HERE WE DEAL WITH FREQUENCIES IN MONTH AND WORK ON JULIAN DAYS.
!-
    ELSE
      DATE_NOW = ITAU2DATE (ITAU,DATE0,DT)
      DATE_LAST_ACT = ITAU2DATE (LAST_ACTION,DATE0,DT)
      CALL JU2YMDS (DATE_LAST_ACT,YEAR,MONTH,DAY,SEC)
      MONTHP1 = MONTH-FREQ
      YEARP = YEAR
!-
!---- HERE WE COMPUTE WHAT LOGICALLY SHOULD BE THE NEXT MONTH
!-
      IF (MONTH >= 13) THEN
        YEARP = YEAR+1
        MONTHP1 = MONTHP1-12
      ENDIF
      CALL YMDS2JU (YEAR,MONTHP1,DAY,SEC,DATE_MPF)
!-
!---- BUT IT COULD BE THAT BECAUSE OF A SHORTER MONTH OR A BAD
!---- STARTING DATE THAT WE END UP FURTHER THAN WE SHOULD BE.
!---- THUS WE COMPUTE THE FIRST DAY OF THE NEXT MONTH.
!---- WE CAN NOT BE BEYOND THIS DATE AND IF WE ARE CLOSE
!---- THEN WE WILL TAKE IT AS IT IS BETTER.
!-
      MONTHP1 = MONTH+ABS(FREQ)
      YEARP=YEAR
      IF (MONTHP1 >= 13) THEN
        YEARP = YEAR+1
        MONTHP1 = MONTHP1 -12
      ENDIF
      DAYP = 1
      SECP = 0.0
      CALL YMDS2JU (YEARP,MONTHP1,DAYP,SECP,DATE_MP1)
!-
!---- IF DATE_MP1 IS SMALLER THAN DATE_MPF OR ONLY LESS THAN 4 DAYS
!---- LARGER THEN WE TAKE IT. THIS NEEDED TO ENSURE THAT SHORT MONTH
!---- LIKE FEBRUARY DO NOT MESS UP THE THING !
!-
      IF (DATE_MP1-DATE_MPF < 4.) THEN
        DATE_NEXT_ACT = DATE_MP1
      ELSE
        DATE_NEXT_ACT = DATE_MPF
      ENDIF
      DATE_NEXT_CHECK = ITAU2DATE (NEXT_CHECK_ITAU,DATE0,DT)
!-
!---- TRANSFORM THE DATES INTO TIME-STEPS FOR THE NEEDED PRECISIONS.
!-
      NEXT_ACT_ITAU = &
 &      LAST_ACTION+INT((DATE_NEXT_ACT-DATE_LAST_ACT)*(ONE_DAY/DT))
!-----
      IF (   ABS(ITAU-NEXT_ACT_ITAU) &
 &        <= ABS( NEXT_CHECK_ITAU-NEXT_ACT_ITAU)) THEN
        DO_ACTION = .TRUE.
        IF (CHECK) THEN
          WRITE(*,*) &
 &         'ACT-TIME : ITAU, NEXT_ACT_ITAU, NEXT_CHECK_ITAU : ', &
 &         ITAU,NEXT_ACT_ITAU,NEXT_CHECK_ITAU
          CALL JU2YMDS (DATE_NOW,YEAR,MONTH,DAY,SEC)
          WRITE(*,*) 'ACT-TIME : Y, M, D, S : ',YEAR,MONTH,DAY,SEC
          WRITE(*,*) &
 &         'ACT-TIME : DATE_MP1, DATE_MPF : ',DATE_MP1,DATE_MPF
        ENDIF
      ELSE
        DO_ACTION = .FALSE.
      ENDIF
    ENDIF
!-
    IF (CHECK) THEN
      WRITE(*,*) "ISITTIME 2.0 ", &
 &     DATE_NEXT_CHECK,DATE_NEXT_ACT,ABS(DT_ACTION-FREQ), &
 &     ABS(DT_ACTION+DT_CHECK-FREQ),DT_ACTION,DT_CHECK, &
 &     NEXT_CHECK_ITAU,DO_ACTION
    ENDIF
  ELSE
    DO_ACTION=.FALSE.
  ENDIF
!----------------------
END SUBROUTINE ISITTIME
!-
!===
!-
SUBROUTINE IOCONF_CALENDAR (STR)
!---------------------------------------------------------------------
!- THIS ROUTINE ALLOWS TO CONFIGURE THE CALENDAR TO BE USED.
!- THIS OPERATION IS ONLY ALLOWED ONCE AND THE FIRST CALL TO
!- YMDS2JU OR JU2YMSD WILL LOCK THE CURRENT CONFIGURATION.
!- THE ARGUMENT TO IOCONF_CALENDAR CAN BE ANY OF THE FOLLOWING :
!-  - GREGORIAN : THIS IS THE GREGORIAN CALENDAR (DEFAULT HERE)
!-  - NOLEAP    : A CALENDAR WITHOUT LEAP YEARS = 365 DAYS
!-  - XXXD      : A CALENDAR OF XXX DAYS (HAS TO BE A MODULO OF 12)
!-                WITH 12 MONTH OF EQUAL LENGTH
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  CHARACTER(LEN=*),INTENT(IN) :: STR
!-
  INTEGER(KIND=I4) :: LENG,IPOS
  CHARACTER(LEN=20) :: STR_W
!---------------------------------------------------------------------
!-
! CLEAN UP THE SRING !
!-
  STR_W = STR
  CALL STRUPPERCASE (STR_W)
!-
  IF (.NOT.LOCK_ONE_YEAR) THEN
!---
    LOCK_ONE_YEAR=.TRUE.
!---
    SELECT CASE(TRIM(STR_W))
    CASE('GREGORIAN','STANDARD','PROLEPTIC_GREGORIAN')
      CALENDAR_USED = 'GREGORIAN'
      ONE_YEAR = 365.2425
      MON_LEN(:)=(/31,28,31,30,31,30,31,31,30,31,30,31/)
    CASE('NOLEAP','365_DAY','365D')
      CALENDAR_USED = 'NOLEAP'
      ONE_YEAR = 365.0
      MON_LEN(:)=(/31,28,31,30,31,30,31,31,30,31,30,31/)
    CASE('ALL_LEAP','366_DAY','366D')
      CALENDAR_USED = 'ALL_LEAP'
      ONE_YEAR = 366.0
      MON_LEN(:)=(/31,29,31,30,31,30,31,31,30,31,30,31/)
    CASE('360_DAY','360D')
      CALENDAR_USED = '360D'
      ONE_YEAR = 360.0
      MON_LEN(:)=(/30,30,30,30,30,30,30,30,30,30,30,30/)
    CASE('JULIAN')
      CALENDAR_USED = 'JULIAN'
      ONE_YEAR = 365.25
      MON_LEN(:)=(/31,28,31,30,31,30,31,31,30,31,30,31/)
    CASE DEFAULT
      IPOS = INDEX(STR_W,'D')
      IF (IPOS == 4) THEN
        READ(STR_W(1:3),'(I3)') LENG
        IF ( (MOD(LENG,12) == 0).AND.(LENG > 1) ) THEN
          CALENDAR_USED = STR_W
          ONE_YEAR = LENG
          MON_LEN(:) = LENG/12
        ELSE
          CALL IPSLERR (3,'IOCONF_CALENDAR', &
 &         'THE LENGTH OF THE YEAR AS TO BE A MODULO OF 12', &
 &         'SO THAT IT CAN BE DIVIDED INTO 12 MONTH OF EQUAL LENGTH', &
 &         TRIM(STR_W))
        ENDIF
      ELSE
        CALL IPSLERR (3,'IOCONF_CALENDAR', &
 &       'UNRECOGNIZED INPUT, PLEASE CHECK THE MAN PAGES.', &
 &       TRIM(STR_W),' ')
      ENDIF
    END SELECT
  ELSE
    WRITE(STR_W,'(F10.4)') ONE_YEAR
    CALL IPSLERR (2,'IOCONF_CALENDAR', &
 &   'THE CALENDAR WAS ALREADY USED OR CONFIGURED. YOU ARE NOT', &
 &   'ALLOWED TO CHANGE IT AGAIN. '// &
 &   'THE FOLLOWING LENGTH OF YEAR IS USED : ',TRIM(ADJUSTL(STR_W)))
  ENDIF
!-----------------------------
END SUBROUTINE IOCONF_CALENDAR
!-
!===
!-
SUBROUTINE IOCONF_STARTDATE_SIMPLE (JULIAN)
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  REAL(KIND=DP),INTENT(IN) :: JULIAN
!-
  INTEGER(KIND=I4) :: JULIAN_DAY
  REAL(KIND=DP)    :: JULIAN_SEC
!---------------------------------------------------------------------
  JULIAN_DAY = INT(JULIAN)
  JULIAN_SEC = (JULIAN-JULIAN_DAY)*ONE_DAY
!-
  CALL IOCONF_STARTDATE_INTERNAL (JULIAN_DAY,JULIAN_SEC)
!-------------------------------------
END SUBROUTINE IOCONF_STARTDATE_SIMPLE
!-
!===
!-
SUBROUTINE IOCONF_STARTDATE_YMDS (YEAR,MONTH,DAY,SEC)
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: YEAR,MONTH,DAY
  REAL(KIND=DP),INTENT(IN)    :: SEC
!-
  INTEGER(KIND=I4) :: JULIAN_DAY
  REAL(KIND=DP)    :: JULIAN_SEC
!---------------------------------------------------------------------
  CALL YMDS2JU_INTERNAL (YEAR,MONTH,DAY,SEC,JULIAN_DAY,JULIAN_SEC)
!-
  CALL IOCONF_STARTDATE_INTERNAL (JULIAN_DAY,JULIAN_SEC)
!-----------------------------------
END SUBROUTINE IOCONF_STARTDATE_YMDS
!-
!===
!-
SUBROUTINE IOCONF_STARTDATE_INTERNAL (JULIAN_DAY,JULIAN_SEC)
!---------------------------------------------------------------------
! THIS SUBROUTINE ALLOWS TO SET THE STARTDATE FOR LATER
! USE. IT ALLOWS THE APPLICATIONS TO ACCESS THE DATE DIRECTLY FROM
! THE TIMESTEP. IN ORDER TO AVOID ANY PROBLEMS THE START DATE WILL
! BE LOCKED AND CAN NOT BE CHANGED ONCE SET.
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN)  :: JULIAN_DAY
  REAL(KIND=DP),INTENT(IN)     :: JULIAN_SEC
!-
  CHARACTER(LEN=70) :: STR70A,STR70B
!---------------------------------------------------------------------
  IF (.NOT.LOCK_STARTDATE) THEN
    START_DAY = JULIAN_DAY
    START_SEC = JULIAN_SEC
    LOCK_STARTDATE = .TRUE.
  ELSE
    WRITE(STR70A,'("THE DATE YOU TRIED TO SET : ",F10.4)') &
 &   JULIAN_DAY,JULIAN_SEC/ONE_DAY
    WRITE(STR70B, &
 &   '("THE DATE WHICH WAS ALREADY SET IN THE CALENDAR : ",F10.4)') &
 &   START_DAY+START_SEC/ONE_DAY
    CALL IPSLERR (2,'IOCONF_STARTDATE', &
 &   'THE START DATE HAS ALREADY BEEN SET AND YOU TRIED TO CHANGE IT', &
 &   STR70A,STR70B)
  ENDIF
!---------------------------------------
END SUBROUTINE IOCONF_STARTDATE_INTERNAL
!-
!===
!-
SUBROUTINE IOGET_CALENDAR_STR (STR)
!---------------------------------------------------------------------
!- THIS SUBROUTINE RETURNS THE NAME OF THE CALENDAR USED HERE.
!- THREE OPTIONS EXIST :
!-  - GREGORIAN : THIS IS THE GREGORIAN CALENDAR (DEFAULT HERE)
!-  - NOLEAP    : A CALENDAR WITHOUT LEAP YEARS = 365 DAYS
!-  - XXXD      : A CALENDAR OF XXX DAYS (HAS TO BE A MODULO OF 12)
!-                WITH 12 MONTH OF EQUAL LENGTH
!-
!- THIS ROUTINE WILL LOCK THE CALENDAR.
!- YOU DO NOT WANT IT TO CHANGE AFTER YOUR INQUIRY.
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  CHARACTER(LEN=*),INTENT(OUT) :: STR
!---------------------------------------------------------------------
  LOCK_ONE_YEAR = .TRUE.
!-
  STR = CALENDAR_USED
!--------------------------------
END SUBROUTINE IOGET_CALENDAR_STR
!-
!===
!-
SUBROUTINE IOGET_CALENDAR_REAL1 (LONG_YEAR)
!---------------------------------------------------------------------
!- THIS SUBROUTINE RETURNS THE NAME OF THE CALENDAR USED HERE.
!- THREE OPTIONS EXIST :
!-  - GREGORIAN : THIS IS THE GREGORIAN CALENDAR (DEFAULT HERE)
!-  - NOLEAP    : A CALENDAR WITHOUT LEAP YEARS = 365 DAYS
!-  - XXXD      : A CALENDAR OF XXX DAYS (HAS TO BE A MODULO OF 12)
!-                WITH 12 MONTH OF EQUAL LENGTH
!-
!- THIS ROUTINE WILL LOCK THE CALENDAR.
!- YOU DO NOT WANT IT TO CHANGE AFTER YOUR INQUIRY.
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  REAL(KIND=DP),INTENT(OUT) :: LONG_YEAR
!---------------------------------------------------------------------
  LONG_YEAR = ONE_YEAR
  LOCK_ONE_YEAR = .TRUE.
!----------------------------------
END SUBROUTINE IOGET_CALENDAR_REAL1
!-
!===
!-
SUBROUTINE IOGET_CALENDAR_REAL2 (LONG_YEAR,LONG_DAY)
!---------------------------------------------------------------------
!- THIS SUBROUTINE RETURNS THE NAME OF THE CALENDAR USED HERE.
!- THREE OPTIONS EXIST :
!-  - GREGORIAN : THIS IS THE GREGORIAN CALENDAR (DEFAULT HERE)
!-  - NOLEAP    : A CALENDAR WITHOUT LEAP YEARS = 365 DAYS
!-  - XXXD      : A CALENDAR OF XXX DAYS (HAS TO BE A MODULO OF 12)
!-                WITH 12 MONTH OF EQUAL LENGTH
!-
!- THIS ROUTINE WILL LOCK THE CALENDAR.
!- YOU DO NOT WANT IT TO CHANGE AFTER YOUR INQUIRY.
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  REAL(KIND=DP),INTENT(OUT) :: LONG_YEAR,LONG_DAY
!---------------------------------------------------------------------
  LONG_YEAR = ONE_YEAR
  LONG_DAY  = ONE_DAY
  LOCK_ONE_YEAR = .TRUE.
!----------------------------------
END SUBROUTINE IOGET_CALENDAR_REAL2
!-
!===
!-
INTEGER(KIND=I4) FUNCTION IOGET_MON_LEN (YEAR,MONTH)
!!--------------------------------------------------------------------
!! THE "IOGET_MON_LEN" FUNCTION RETURNS
!! THE NUMBER OF DAYS IN A "MONTH" OF A "YEAR",
!! IN THE CURRENT CALENDAR.
!!
!! INTEGER(KIND=I4) FUNCTION IOGET_MON_LEN (YEAR,MONTH)
!!
!! INPUT
!!
!! (I) YEAR  : YEAR
!! (I) MONTH : MONTH IN THE YEAR (1 --> 12)
!!
!! OUTPUT
!!
!! (I) IOGET_MON_LEN : NUMBER OF DAYS IN THE MONTH
!!--------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: YEAR,MONTH
!-
  INTEGER(KIND=I4) :: ML
!---------------------------------------------------------------------
  IF ( (MONTH >= 1).AND.(MONTH <= 12) ) THEN
    IF ( (ONE_YEAR > 365.0).AND.(ONE_YEAR < 366.0) ) THEN
!---- "GREGORIAN" OR "JULIAN"
      ML = MON_LEN(MONTH)
      IF (MONTH == 2) THEN
        IF (ABS(ONE_YEAR-365.2425) <= EPSILON(ONE_YEAR) ) THEN
!-------- "GREGORIAN"
          IF (    ((MOD(YEAR,4) == 0).AND.(MOD(YEAR,100) /= 0)) &
              .OR.(MOD(YEAR,400) == 0) ) THEN
            ML = ML+1
          ENDIF
        ELSE
!-------- "JULIAN"
          IF (MOD(YEAR,4) == 0) THEN
            ML = ML+1
          ENDIF
        ENDIF
      ENDIF
      IOGET_MON_LEN = ML
    ELSE
!---- "NO LEAP" OR "ALL LEAP" OR "CALENDAR WITH REGULAR MONTH"
      IOGET_MON_LEN = MON_LEN(MONTH)
    ENDIF
  ELSE
    CALL IPSLERR (3,'IOGET_MON_LEN', &
 &    'THE NUMBER OF THE MONTH','MUST BE BETWEEN','1 AND 12')
  ENDIF
!-------------------------
END FUNCTION IOGET_MON_LEN
!-
!===
!-
SUBROUTINE IOGET_TIMESTAMP (STRING)
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  CHARACTER(LEN=30),INTENT(OUT) :: STRING
!-
  INTEGER(KIND=I4) :: DATE_TIME(8)
  CHARACTER(LEN=10) :: BIGBEN(3)
!---------------------------------------------------------------------
  IF (INDEX(TIME_STAMP,'XXXXXX') > 0) THEN
    CALL DATE_AND_TIME (BIGBEN(1),BIGBEN(2),BIGBEN(3),DATE_TIME)
!---
    WRITE(TIME_STAMP, &
 &   "(I4.4,'-',A3,'-',I2.2,' ',I2.2,':',I2.2,':',I2.2,' GMT',A5)") &
 &   DATE_TIME(1),CAL(DATE_TIME(2)),DATE_TIME(3),DATE_TIME(5), &
 &   DATE_TIME(6),DATE_TIME(7),BIGBEN(3)
  ENDIF
!-
  STRING = TIME_STAMP
!-----------------------------
END SUBROUTINE IOGET_TIMESTAMP
!-
!===
!-
SUBROUTINE TIME_ADD &
 &  (YEAR_S,MONTH_S,DAY_S,SEC_S,SEC_INCREMENT, &
 &   YEAR_E,MONTH_E,DAY_E,SEC_E)
!---------------------------------------------------------------------
!- THIS SUBROUTINE ALLOWS TO INCREMENT A DATE BY A NUMBER OF SECONDS.
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: YEAR_S,MONTH_S,DAY_S
  REAL(KIND=DP),INTENT(IN)    :: SEC_S
!-
! TIME IN SECONDS TO BE ADDED TO THE DATE
!-
  REAL(KIND=DP),INTENT(IN)    :: SEC_INCREMENT
!-
  INTEGER(KIND=I4),INTENT(OUT) :: YEAR_E,MONTH_E,DAY_E
  REAL(KIND=DP),INTENT(OUT)    :: SEC_E
!-
  INTEGER(KIND=I4) :: JULIAN_DAY
  REAL(KIND=DP)    :: JULIAN_SEC
!---------------------------------------------------------------------
  CALL YMDS2JU_INTERNAL &
 &  (YEAR_S,MONTH_S,DAY_S,SEC_S,JULIAN_DAY,JULIAN_SEC)
!-
  JULIAN_SEC = JULIAN_SEC+SEC_INCREMENT
!-
  CALL JU2YMDS_INTERNAL &
 &  (JULIAN_DAY,JULIAN_SEC,YEAR_E,MONTH_E,DAY_E,SEC_E)
!----------------------
END SUBROUTINE TIME_ADD
!-
!===
!-
SUBROUTINE TIME_DIFF &
 &  (YEAR_S,MONTH_S,DAY_S,SEC_S,YEAR_E,MONTH_E,DAY_E,SEC_E,SEC_DIFF)
!---------------------------------------------------------------------
!- THIS SUBROUTINE ALLOWS TO DETERMINE THE NUMBER OF SECONDS
!- BETWEEN TWO DATES.
!---------------------------------------------------------------------
  IMPLICIT NONE
!-
  INTEGER(KIND=I4),INTENT(IN) :: YEAR_S,MONTH_S,DAY_S
  REAL(KIND=DP),INTENT(IN)    :: SEC_S
  INTEGER(KIND=I4),INTENT(IN) :: YEAR_E,MONTH_E,DAY_E
  REAL(KIND=DP),INTENT(IN)    :: SEC_E
!-
! TIME IN SECONDS BETWEEN THE TWO DATES
!-
  REAL(KIND=DP),INTENT(OUT)    :: SEC_DIFF
!-
  INTEGER(KIND=I4) :: JULIAN_DAY_S,JULIAN_DAY_E,DAY_DIFF
  REAL(KIND=DP)    :: JULIAN_SEC_S,JULIAN_SEC_E
!---------------------------------------------------------------------

  CALL YMDS2JU_INTERNAL &
 &  (YEAR_S,MONTH_S,DAY_S,SEC_S,JULIAN_DAY_S,JULIAN_SEC_S)
  CALL YMDS2JU_INTERNAL &
 &  (YEAR_E,MONTH_E,DAY_E,SEC_E,JULIAN_DAY_E,JULIAN_SEC_E)
!-
  DAY_DIFF = JULIAN_DAY_E-JULIAN_DAY_S
  SEC_DIFF = JULIAN_SEC_E-JULIAN_SEC_S
!-
  SEC_DIFF = SEC_DIFF+DAY_DIFF*ONE_DAY
!-----------------------
END SUBROUTINE TIME_DIFF
!-
!===
!-
END MODULE CALENDAR
